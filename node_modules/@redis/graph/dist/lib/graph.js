"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// https://github.com/RedisGraph/RedisGraph/blob/master/src/resultset/formatters/resultset_formatter.h#L20
var GraphValueTypes;
(function (GraphValueTypes) {
    GraphValueTypes[GraphValueTypes["UNKNOWN"] = 0] = "UNKNOWN";
    GraphValueTypes[GraphValueTypes["NULL"] = 1] = "NULL";
    GraphValueTypes[GraphValueTypes["STRING"] = 2] = "STRING";
    GraphValueTypes[GraphValueTypes["INTEGER"] = 3] = "INTEGER";
    GraphValueTypes[GraphValueTypes["BOOLEAN"] = 4] = "BOOLEAN";
    GraphValueTypes[GraphValueTypes["DOUBLE"] = 5] = "DOUBLE";
    GraphValueTypes[GraphValueTypes["ARRAY"] = 6] = "ARRAY";
    GraphValueTypes[GraphValueTypes["EDGE"] = 7] = "EDGE";
    GraphValueTypes[GraphValueTypes["NODE"] = 8] = "NODE";
    GraphValueTypes[GraphValueTypes["PATH"] = 9] = "PATH";
    GraphValueTypes[GraphValueTypes["MAP"] = 10] = "MAP";
    GraphValueTypes[GraphValueTypes["POINT"] = 11] = "POINT";
})(GraphValueTypes || (GraphValueTypes = {}));
class Graph {
    #client;
    #name;
    #metadata;
    constructor(client, name) {
        this.#client = client;
        this.#name = name;
    }
    async query(query, options) {
        return this.#parseReply(await this.#client.graph.query(this.#name, query, options, true));
    }
    async roQuery(query, options) {
        return this.#parseReply(await this.#client.graph.roQuery(this.#name, query, options, true));
    }
    #setMetadataPromise;
    #updateMetadata() {
        this.#setMetadataPromise ??= this.#setMetadata()
            .finally(() => this.#setMetadataPromise = undefined);
        return this.#setMetadataPromise;
    }
    // DO NOT use directly, use #updateMetadata instead
    async #setMetadata() {
        const [labels, relationshipTypes, propertyKeys] = await Promise.all([
            this.#client.graph.roQuery(this.#name, 'CALL db.labels()'),
            this.#client.graph.roQuery(this.#name, 'CALL db.relationshipTypes()'),
            this.#client.graph.roQuery(this.#name, 'CALL db.propertyKeys()')
        ]);
        this.#metadata = {
            labels: this.#cleanMetadataArray(labels.data),
            relationshipTypes: this.#cleanMetadataArray(relationshipTypes.data),
            propertyKeys: this.#cleanMetadataArray(propertyKeys.data)
        };
        return this.#metadata;
    }
    #cleanMetadataArray(arr) {
        return arr.map(([value]) => value);
    }
    #getMetadata(key, id) {
        return this.#metadata?.[key][id] ?? this.#getMetadataAsync(key, id);
    }
    // DO NOT use directly, use #getMetadata instead
    async #getMetadataAsync(key, id) {
        const value = (await this.#updateMetadata())[key][id];
        if (value === undefined)
            throw new Error(`Cannot find value from ${key}[${id}]`);
        return value;
    }
    // TODO: reply type
    async #parseReply(reply) {
        if (!reply.data)
            return reply;
        const promises = [], parsed = {
            metadata: reply.metadata,
            data: reply.data.map((row) => {
                const data = {};
                for (let i = 0; i < row.length; i++) {
                    data[reply.headers[i][1]] = this.#parseValue(row[i], promises);
                }
                return data;
            })
        };
        if (promises.length)
            await Promise.all(promises);
        return parsed;
    }
    #parseValue([valueType, value], promises) {
        switch (valueType) {
            case GraphValueTypes.NULL:
                return null;
            case GraphValueTypes.STRING:
            case GraphValueTypes.INTEGER:
                return value;
            case GraphValueTypes.BOOLEAN:
                return value === 'true';
            case GraphValueTypes.DOUBLE:
                return parseFloat(value);
            case GraphValueTypes.ARRAY:
                return value.map(x => this.#parseValue(x, promises));
            case GraphValueTypes.EDGE:
                return this.#parseEdge(value, promises);
            case GraphValueTypes.NODE:
                return this.#parseNode(value, promises);
            case GraphValueTypes.PATH:
                return {
                    nodes: value[0][1].map(([, node]) => this.#parseNode(node, promises)),
                    edges: value[1][1].map(([, edge]) => this.#parseEdge(edge, promises))
                };
            case GraphValueTypes.MAP:
                const map = {};
                for (let i = 0; i < value.length; i++) {
                    map[value[i++]] = this.#parseValue(value[i], promises);
                }
                return map;
            case GraphValueTypes.POINT:
                return {
                    latitude: parseFloat(value[0]),
                    longitude: parseFloat(value[1])
                };
            default:
                throw new Error(`unknown scalar type: ${valueType}`);
        }
    }
    #parseEdge([id, relationshipTypeId, sourceId, destinationId, properties], promises) {
        const edge = {
            id,
            sourceId,
            destinationId,
            properties: this.#parseProperties(properties, promises)
        };
        const relationshipType = this.#getMetadata('relationshipTypes', relationshipTypeId);
        if (relationshipType instanceof Promise) {
            promises.push(relationshipType.then(value => edge.relationshipType = value));
        }
        else {
            edge.relationshipType = relationshipType;
        }
        return edge;
    }
    #parseNode([id, labelIds, properties], promises) {
        const labels = new Array(labelIds.length);
        for (let i = 0; i < labelIds.length; i++) {
            const value = this.#getMetadata('labels', labelIds[i]);
            if (value instanceof Promise) {
                promises.push(value.then(value => labels[i] = value));
            }
            else {
                labels[i] = value;
            }
        }
        return {
            id,
            labels,
            properties: this.#parseProperties(properties, promises)
        };
    }
    #parseProperties(raw, promises) {
        const parsed = {};
        for (const [id, type, value] of raw) {
            const parsedValue = this.#parseValue([type, value], promises), key = this.#getMetadata('propertyKeys', id);
            if (key instanceof Promise) {
                promises.push(key.then(key => parsed[key] = parsedValue));
            }
            else {
                parsed[key] = parsedValue;
            }
        }
        return parsed;
    }
}
exports.default = Graph;
