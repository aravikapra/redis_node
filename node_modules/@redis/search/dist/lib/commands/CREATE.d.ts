import { RedisArgument, SimpleStringReply, CommandArguments } from '@redis/client/dist/lib/RESP/types';
import { RedisVariadicArgument } from '@redis/client/dist/lib/commands/generic-transformers';
export declare const SCHEMA_FIELD_TYPE: {
    readonly TEXT: "TEXT";
    readonly NUMERIC: "NUMERIC";
    readonly GEO: "GEO";
    readonly TAG: "TAG";
    readonly VECTOR: "VECTOR";
    readonly GEOSHAPE: "GEOSHAPE";
};
export type SchemaFieldType = typeof SCHEMA_FIELD_TYPE[keyof typeof SCHEMA_FIELD_TYPE];
type SchemaField<T extends SchemaFieldType, E = Record<PropertyKey, unknown>> = T | ({
    type: T;
    AS?: RedisArgument;
} & E);
type SchemaCommonField<T extends SchemaFieldType, E = Record<PropertyKey, unknown>> = SchemaField<T, ({
    SORTABLE?: boolean | 'UNF';
    NOINDEX?: boolean;
} & E)>;
export declare const SCHEMA_TEXT_FIELD_PHONETIC: {
    readonly DM_EN: "dm:en";
    readonly DM_FR: "dm:fr";
    readonly FM_PT: "dm:pt";
    readonly DM_ES: "dm:es";
};
export type SchemaTextFieldPhonetic = typeof SCHEMA_TEXT_FIELD_PHONETIC[keyof typeof SCHEMA_TEXT_FIELD_PHONETIC];
type SchemaTextField = SchemaCommonField<typeof SCHEMA_FIELD_TYPE['TEXT'], {
    NOSTEM?: boolean;
    WEIGHT?: number;
    PHONETIC?: SchemaTextFieldPhonetic;
    WITHSUFFIXTRIE?: boolean;
}>;
type SchemaNumericField = SchemaCommonField<typeof SCHEMA_FIELD_TYPE['NUMERIC']>;
type SchemaGeoField = SchemaCommonField<typeof SCHEMA_FIELD_TYPE['GEO']>;
type SchemaTagField = SchemaCommonField<typeof SCHEMA_FIELD_TYPE['TAG'], {
    SEPARATOR?: RedisArgument;
    CASESENSITIVE?: boolean;
    WITHSUFFIXTRIE?: boolean;
}>;
export declare const SCHEMA_VECTOR_FIELD_ALGORITHM: {
    readonly FLAT: "FLAT";
    readonly HNSW: "HNSW";
};
export type SchemaVectorFieldAlgorithm = typeof SCHEMA_VECTOR_FIELD_ALGORITHM[keyof typeof SCHEMA_VECTOR_FIELD_ALGORITHM];
type SchemaVectorField<T extends SchemaVectorFieldAlgorithm, A extends Record<string, unknown>> = SchemaField<typeof SCHEMA_FIELD_TYPE['VECTOR'], {
    ALGORITHM: T;
    TYPE: string;
    DIM: number;
    DISTANCE_METRIC: 'L2' | 'IP' | 'COSINE';
    INITIAL_CAP?: number;
} & A>;
type SchemaFlatVectorField = SchemaVectorField<typeof SCHEMA_VECTOR_FIELD_ALGORITHM['FLAT'], {
    BLOCK_SIZE?: number;
}>;
type SchemaHNSWVectorField = SchemaVectorField<typeof SCHEMA_VECTOR_FIELD_ALGORITHM['HNSW'], {
    M?: number;
    EF_CONSTRUCTION?: number;
    EF_RUNTIME?: number;
}>;
export declare const SCHEMA_GEO_SHAPE_COORD_SYSTEM: {
    readonly SPHERICAL: "SPHERICAL";
    readonly FLAT: "FLAT";
};
export type SchemaGeoShapeFieldCoordSystem = typeof SCHEMA_GEO_SHAPE_COORD_SYSTEM[keyof typeof SCHEMA_GEO_SHAPE_COORD_SYSTEM];
type SchemaGeoShapeField = SchemaField<typeof SCHEMA_FIELD_TYPE['GEOSHAPE'], {
    COORD_SYSTEM?: SchemaGeoShapeFieldCoordSystem;
}>;
export interface RediSearchSchema {
    [field: string]: (SchemaTextField | SchemaNumericField | SchemaGeoField | SchemaTagField | SchemaFlatVectorField | SchemaHNSWVectorField | SchemaGeoShapeField);
}
export declare function pushSchema(args: CommandArguments, schema: RediSearchSchema): void;
export declare const REDISEARCH_LANGUAGE: {
    readonly ARABIC: "Arabic";
    readonly BASQUE: "Basque";
    readonly CATALANA: "Catalan";
    readonly DANISH: "Danish";
    readonly DUTCH: "Dutch";
    readonly ENGLISH: "English";
    readonly FINNISH: "Finnish";
    readonly FRENCH: "French";
    readonly GERMAN: "German";
    readonly GREEK: "Greek";
    readonly HUNGARIAN: "Hungarian";
    readonly INDONESAIN: "Indonesian";
    readonly IRISH: "Irish";
    readonly ITALIAN: "Italian";
    readonly LITHUANIAN: "Lithuanian";
    readonly NEPALI: "Nepali";
    readonly NORWEIGAN: "Norwegian";
    readonly PORTUGUESE: "Portuguese";
    readonly ROMANIAN: "Romanian";
    readonly RUSSIAN: "Russian";
    readonly SPANISH: "Spanish";
    readonly SWEDISH: "Swedish";
    readonly TAMIL: "Tamil";
    readonly TURKISH: "Turkish";
    readonly CHINESE: "Chinese";
};
export type RediSearchLanguage = typeof REDISEARCH_LANGUAGE[keyof typeof REDISEARCH_LANGUAGE];
export type RediSearchProperty = `${'@' | '$.'}${string}`;
export interface CreateOptions {
    ON?: 'HASH' | 'JSON';
    PREFIX?: RedisVariadicArgument;
    FILTER?: RedisArgument;
    LANGUAGE?: RediSearchLanguage;
    LANGUAGE_FIELD?: RediSearchProperty;
    SCORE?: number;
    SCORE_FIELD?: RediSearchProperty;
    MAXTEXTFIELDS?: boolean;
    TEMPORARY?: number;
    NOOFFSETS?: boolean;
    NOHL?: boolean;
    NOFIELDS?: boolean;
    NOFREQS?: boolean;
    SKIPINITIALSCAN?: boolean;
    STOPWORDS?: RedisVariadicArgument;
}
declare const _default: {
    readonly FIRST_KEY_INDEX: undefined;
    readonly IS_READ_ONLY: true;
    readonly transformArguments: (this: void, index: RedisArgument, schema: RediSearchSchema, options?: CreateOptions) => RedisArgument[];
    readonly transformReply: () => SimpleStringReply<'OK'>;
};
export default _default;
