/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { RedisArgument, RedisFunctions, RedisModules, RedisScript, RedisScripts, RespVersions, TypeMapping } from '../RESP/types';
import { RedisClientType, RedisClientOptions, RedisClientExtensions } from '.';
import { EventEmitter } from 'node:events';
import { CommandOptions } from './commands-queue';
export interface RedisPoolOptions {
    /**
     * The minimum number of clients to keep in the pool (>= 1).
     */
    minimum: number;
    /**
     * The maximum number of clients to keep in the pool (>= {@link RedisPoolOptions.minimum} >= 1).
     */
    maximum: number;
    /**
     * The maximum time a task can wait for a client to become available (>= 0).
     */
    acquireTimeout: number;
    /**
     * TODO
     */
    cleanupDelay: number;
}
export type PoolTask<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions, TYPE_MAPPING extends TypeMapping, T = unknown> = (client: RedisClientType<M, F, S, RESP, TYPE_MAPPING>) => T;
export type RedisClientPoolType<M extends RedisModules = {}, F extends RedisFunctions = {}, S extends RedisScripts = {}, RESP extends RespVersions = 2, TYPE_MAPPING extends TypeMapping = {}> = (RedisClientPool<M, F, S, RESP, TYPE_MAPPING> & RedisClientExtensions<M, F, S, RESP, TYPE_MAPPING>);
export declare class RedisClientPool<M extends RedisModules = {}, F extends RedisFunctions = {}, S extends RedisScripts = {}, RESP extends RespVersions = 2, TYPE_MAPPING extends TypeMapping = {}> extends EventEmitter {
    private static _createCommand;
    private static _createModuleCommand;
    private static _createFunctionCommand;
    private static _createScriptCommand;
    static create<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions, TYPE_MAPPING extends TypeMapping = {}>(clientOptions?: RedisClientOptions<M, F, S, RESP, TYPE_MAPPING>, options?: Partial<RedisPoolOptions>): RedisClientPoolType<M, F, S, RESP, TYPE_MAPPING>;
    private static _DEFAULTS;
    private readonly _clientFactory;
    private readonly _options;
    private readonly _idleClients;
    /**
     * The number of idle clients.
     */
    get idleClients(): number;
    private readonly _clientsInUse;
    /**
     * The number of clients in use.
     */
    get clientsInUse(): number;
    private readonly _connectingClients;
    /**
     * The number of clients that are currently connecting.
     */
    get connectingClients(): number;
    /**
     * The total number of clients in the pool (including connecting, idle, and in use).
     */
    get totalClients(): number;
    private readonly _tasksQueue;
    /**
     * The number of tasks waiting for a client to become available.
     */
    get tasksQueueLength(): number;
    private _isOpen;
    /**
     * Whether the pool is open (either connecting or connected).
     */
    get isOpen(): boolean;
    private _isClosing;
    /**
     * Whether the pool is closing (*not* closed).
     */
    get isClosing(): boolean;
    /**
     * You are probably looking for {@link RedisClient.createPool `RedisClient.createPool`},
     * {@link RedisClientPool.fromClient `RedisClientPool.fromClient`},
     * or {@link RedisClientPool.fromOptions `RedisClientPool.fromOptions`}...
     */
    constructor(clientFactory: () => RedisClientType<M, F, S, RESP, TYPE_MAPPING>, options?: Partial<RedisPoolOptions>);
    private _self;
    private _commandOptions?;
    withCommandOptions<OPTIONS extends CommandOptions<TYPE_MAPPING>, TYPE_MAPPING extends TypeMapping>(options: OPTIONS): RedisClientPoolType<M, F, S, RESP, TYPE_MAPPING extends TypeMapping ? TYPE_MAPPING : {}>;
    private _commandOptionsProxy;
    /**
     * Override the `typeMapping` command option
     */
    withTypeMapping<TYPE_MAPPING extends TypeMapping>(typeMapping: TYPE_MAPPING): RedisClientPoolType<M, F, S, RESP, TYPE_MAPPING extends TypeMapping ? TYPE_MAPPING : {}>;
    /**
     * Override the `abortSignal` command option
     */
    withAbortSignal(abortSignal: AbortSignal): RedisClientPoolType<M, F, S, RESP, TYPE_MAPPING>;
    /**
     * Override the `asap` command option to `true`
     * TODO: remove?
     */
    asap(): RedisClientPoolType<M, F, S, RESP, TYPE_MAPPING>;
    connect(): Promise<RedisClientPoolType<M, F, S, RESP, TYPE_MAPPING> | undefined>;
    private _create;
    execute<T>(fn: PoolTask<M, F, S, RESP, TYPE_MAPPING, T>): Promise<T>;
    private _executeTask;
    private _returnClient;
    cleanupTimeout?: NodeJS.Timeout;
    private _scheduleCleanup;
    private _cleanup;
    sendCommand(args: Array<RedisArgument>, options?: CommandOptions): Promise<Promise<import("../RESP/types").ReplyUnion>>;
    executeScript(script: RedisScript, args: Array<RedisArgument>, options?: CommandOptions): Promise<Promise<import("../RESP/types").ReplyUnion>>;
    close(): Promise<void>;
    destroy(): void;
}
