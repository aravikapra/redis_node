"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = __importDefault(require("../commands"));
const socket_1 = __importDefault(require("./socket"));
const commands_queue_1 = __importDefault(require("./commands-queue"));
const node_events_1 = require("node:events");
const commander_1 = require("../commander");
const errors_1 = require("../errors");
const node_url_1 = require("node:url");
const pub_sub_1 = require("./pub-sub");
const multi_command_1 = __importDefault(require("./multi-command"));
const HELLO_1 = __importDefault(require("../commands/HELLO"));
const legacy_mode_1 = require("./legacy-mode");
const pool_1 = require("./pool");
class RedisClient extends node_events_1.EventEmitter {
    static _createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function (...args) {
            const redisArgs = command.transformArguments(...args), reply = await this.sendCommand(redisArgs, this._commandOptions);
            return transformReply ?
                transformReply(reply, redisArgs.preserve) :
                reply;
        };
    }
    static _createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function (...args) {
            const redisArgs = command.transformArguments(...args), reply = await this.self.sendCommand(redisArgs, this.self._commandOptions);
            return transformReply ?
                transformReply(reply, redisArgs.preserve) :
                reply;
        };
    }
    static _createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn), transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return async function (...args) {
            const fnArgs = fn.transformArguments(...args), reply = await this.self.sendCommand(prefix.concat(fnArgs), this.self._commandOptions);
            return transformReply ?
                transformReply(reply, fnArgs.preserve) :
                reply;
        };
    }
    static _createScriptCommand(script, resp) {
        const prefix = (0, commander_1.scriptArgumentsPrefix)(script), transformReply = (0, commander_1.getTransformReply)(script, resp);
        return async function (...args) {
            const scriptArgs = script.transformArguments(...args), redisArgs = prefix.concat(scriptArgs), reply = await this.executeScript(script, redisArgs, this._commandOptions);
            return transformReply ?
                transformReply(reply, scriptArgs.preserve) :
                reply;
        };
    }
    static factory(config) {
        const Client = (0, commander_1.attachConfig)({
            BaseClass: RedisClient,
            commands: commands_1.default,
            createCommand: RedisClient._createCommand,
            createModuleCommand: RedisClient._createModuleCommand,
            createFunctionCommand: RedisClient._createFunctionCommand,
            createScriptCommand: RedisClient._createScriptCommand,
            config
        });
        Client.prototype.Multi = multi_command_1.default.extend(config);
        return (options) => {
            // returning a "proxy" to prevent the namespaces.self to leak between "proxies"
            return Object.create(new Client(options));
        };
    }
    static create(options) {
        return RedisClient.factory(options)(options);
    }
    static parseURL(url) {
        // https://www.iana.org/assignments/uri-schemes/prov/redis
        const { hostname, port, protocol, username, password, pathname } = new node_url_1.URL(url), parsed = {
            socket: {
                host: hostname
            }
        };
        if (protocol === 'rediss:') {
            parsed.socket.tls = true;
        }
        else if (protocol !== 'redis:') {
            throw new TypeError('Invalid protocol');
        }
        if (port) {
            parsed.socket.port = Number(port);
        }
        if (username) {
            parsed.username = decodeURIComponent(username);
        }
        if (password) {
            parsed.password = decodeURIComponent(password);
        }
        if (pathname.length > 1) {
            const database = Number(pathname.substring(1));
            if (isNaN(database)) {
                throw new TypeError('Invalid pathname');
            }
            parsed.database = database;
        }
        return parsed;
    }
    self = this;
    _options;
    _socket;
    _queue;
    _selectedDB = 0;
    _commandOptions;
    get options() {
        return this._options;
    }
    get isOpen() {
        return this._socket.isOpen;
    }
    get isReady() {
        return this._socket.isReady;
    }
    get isPubSubActive() {
        return this._queue.isPubSubActive;
    }
    constructor(options) {
        super();
        this._options = this._initiateOptions(options);
        this._queue = this._initiateQueue();
        this._socket = this._initiateSocket();
    }
    _initiateOptions(options) {
        if (options?.url) {
            const parsed = RedisClient.parseURL(options.url);
            if (options.socket) {
                parsed.socket = Object.assign(options.socket, parsed.socket);
            }
            Object.assign(options, parsed);
        }
        if (options?.database) {
            this._selectedDB = options.database;
        }
        if (options?.commandOptions) {
            this._commandOptions = options.commandOptions;
        }
        return options;
    }
    _initiateQueue() {
        return new commands_queue_1.default(this._options?.RESP, this._options?.commandsQueueMaxLength, (channel, listeners) => this.emit('sharded-channel-moved', channel, listeners));
    }
    _initiateSocket() {
        const socketInitiator = async () => {
            const promises = [];
            if (this._selectedDB !== 0) {
                promises.push(this._queue.addCommand(['SELECT', this._selectedDB.toString()], { asap: true }));
            }
            if (this._options?.readonly) {
                promises.push(this._queue.addCommand(commands_1.default.READONLY.transformArguments(), { asap: true }));
            }
            if (this._options?.RESP) {
                const hello = {};
                if (this._options.password) {
                    hello.AUTH = {
                        username: this._options.username ?? 'default',
                        password: this._options.password
                    };
                }
                if (this._options.name) {
                    hello.SETNAME = this._options.name;
                }
                promises.push(this._queue.addCommand(HELLO_1.default.transformArguments(this._options.RESP, hello), { asap: true }));
            }
            else {
                if (this._options?.name) {
                    promises.push(this._queue.addCommand(commands_1.default.CLIENT_SETNAME.transformArguments(this._options.name), { asap: true }));
                }
                if (this._options?.username || this._options?.password) {
                    promises.push(this._queue.addCommand(commands_1.default.AUTH.transformArguments({
                        username: this._options.username,
                        password: this._options.password ?? ''
                    }), { asap: true }));
                }
            }
            const resubscribePromise = this._queue.resubscribe();
            if (resubscribePromise) {
                promises.push(resubscribePromise);
            }
            if (promises.length) {
                this._write();
                await Promise.all(promises);
            }
        };
        return new socket_1.default(socketInitiator, this._options?.socket)
            .on('data', chunk => {
            try {
                this._queue.decoder.write(chunk);
            }
            catch (err) {
                this._queue.decoder.reset();
                this.emit('error', err);
            }
        })
            .on('error', err => {
            this.emit('error', err);
            if (this._socket.isOpen && !this._options?.disableOfflineQueue) {
                this._queue.flushWaitingForReply(err);
            }
            else {
                this._queue.flushAll(err);
            }
        })
            .on('connect', () => this.emit('connect'))
            .on('ready', () => {
            this.emit('ready');
            this._setPingTimer();
            this._maybeScheduleWrite();
        })
            .on('reconnecting', () => this.emit('reconnecting'))
            .on('drain', () => this._maybeScheduleWrite())
            .on('end', () => this.emit('end'));
    }
    _pingTimer;
    _setPingTimer() {
        if (!this._options?.pingInterval || !this._socket.isReady)
            return;
        clearTimeout(this._pingTimer);
        this._pingTimer = setTimeout(() => {
            if (!this._socket.isReady)
                return;
            this.sendCommand(['PING'])
                .then(reply => this.emit('ping-interval', reply))
                .catch(err => this.emit('error', err))
                .finally(() => this._setPingTimer());
        }, this._options.pingInterval);
    }
    withCommandOptions(options) {
        const proxy = Object.create(this.self);
        proxy._commandOptions = options;
        return proxy;
    }
    _commandOptionsProxy(key, value) {
        const proxy = Object.create(this.self);
        proxy._commandOptions = Object.create(this._commandOptions ?? null);
        proxy._commandOptions[key] = value;
        return proxy;
    }
    /**
     * Override the `typeMapping` command option
     */
    withTypeMapping(typeMapping) {
        return this._commandOptionsProxy('typeMapping', typeMapping);
    }
    /**
     * Override the `abortSignal` command option
     */
    withAbortSignal(abortSignal) {
        return this._commandOptionsProxy('abortSignal', abortSignal);
    }
    /**
     * Override the `asap` command option to `true`
     */
    asap() {
        return this._commandOptionsProxy('asap', true);
    }
    /**
     * Create the "legacy" (v3/callback) interface
     */
    legacy() {
        return new legacy_mode_1.RedisLegacyClient(this);
    }
    /**
     * Create {@link RedisClientPool `RedisClientPool`} using this client as a prototype
     */
    createPool(options) {
        return pool_1.RedisClientPool.create(this._options, options);
    }
    duplicate(overrides) {
        return new (Object.getPrototypeOf(this).constructor)({
            ...this._options,
            commandOptions: this._commandOptions,
            ...overrides
        });
    }
    async connect() {
        await this._socket.connect();
        return this;
    }
    sendCommand(args, options) {
        if (!this._socket.isOpen) {
            return Promise.reject(new errors_1.ClientClosedError());
        }
        else if (!this._socket.isReady && this._options?.disableOfflineQueue) {
            return Promise.reject(new errors_1.ClientOfflineError());
        }
        const promise = this._queue.addCommand(args, options);
        this._scheduleWrite();
        return promise;
    }
    async executeScript(script, args, options) {
        try {
            return await this.sendCommand(args, options);
        }
        catch (err) {
            if (!err?.message?.startsWith?.('NOSCRIPT'))
                throw err;
            args[0] = 'EVAL';
            args[1] = script.SCRIPT;
            return await this.sendCommand(args, options);
        }
    }
    async SELECT(db) {
        await this.sendCommand(['SELECT', db.toString()]);
        this._selectedDB = db;
    }
    select = this.SELECT;
    _pubSubCommand(promise) {
        if (promise === undefined)
            return Promise.resolve();
        this._scheduleWrite();
        return promise;
    }
    SUBSCRIBE(channels, listener, bufferMode) {
        return this._pubSubCommand(this._queue.subscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    subscribe = this.SUBSCRIBE;
    UNSUBSCRIBE(channels, listener, bufferMode) {
        return this._pubSubCommand(this._queue.unsubscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    PSUBSCRIBE(patterns, listener, bufferMode) {
        return this._pubSubCommand(this._queue.subscribe(pub_sub_1.PubSubType.PATTERNS, patterns, listener, bufferMode));
    }
    pSubscribe = this.PSUBSCRIBE;
    PUNSUBSCRIBE(patterns, listener, bufferMode) {
        return this._pubSubCommand(this._queue.unsubscribe(pub_sub_1.PubSubType.PATTERNS, patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    SSUBSCRIBE(channels, listener, bufferMode) {
        return this._pubSubCommand(this._queue.subscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
        return this._pubSubCommand(this._queue.unsubscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    getPubSubListeners(type) {
        return this._queue.getPubSubListeners(type);
    }
    extendPubSubChannelListeners(type, channel, listeners) {
        return this._pubSubCommand(this._queue.extendPubSubChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
        return this._pubSubCommand(this._queue.extendPubSubListeners(type, listeners));
    }
    _write() {
        this._socket.write(this._queue.commandsToWrite());
    }
    _scheduledWrite;
    _scheduleWrite() {
        if (!this.isReady || this._scheduledWrite)
            return;
        this._scheduledWrite = setImmediate(() => {
            this._write();
            this._scheduledWrite = undefined;
        });
    }
    _maybeScheduleWrite() {
        if (!this._queue.isWaitingToWrite())
            return;
        this._scheduleWrite();
    }
    /**
     * @internal
     */
    _executePipeline(commands) {
        if (!this._socket.isOpen) {
            return Promise.reject(new errors_1.ClientClosedError());
        }
        const promise = Promise.all(commands.map(({ args }) => this._queue.addCommand(args, {
            typeMapping: this._commandOptions?.typeMapping
        })));
        this._scheduleWrite();
        return promise;
    }
    /**
     * @internal
     */
    async _executeMulti(commands, selectedDB) {
        if (!this._socket.isOpen) {
            return Promise.reject(new errors_1.ClientClosedError());
        }
        const typeMapping = this._commandOptions?.typeMapping, chainId = Symbol('MULTI Chain'), promises = [
            this._queue.addCommand(['MULTI'], { chainId }),
        ];
        for (const { args } of commands) {
            promises.push(this._queue.addCommand(args, {
                chainId,
                typeMapping
            }));
        }
        promises.push(this._queue.addCommand(['EXEC'], { chainId }));
        this._scheduleWrite();
        const results = await Promise.all(promises), execResult = results[results.length - 1];
        if (execResult === null) {
            throw new errors_1.WatchError();
        }
        if (selectedDB !== undefined) {
            this._selectedDB = selectedDB;
        }
        return execResult;
    }
    MULTI() {
        return new this.Multi(this);
    }
    multi = this.MULTI;
    async *scanIterator(options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.scan(cursor, options);
            cursor = reply.cursor;
            yield reply.keys;
        } while (cursor !== '0');
    }
    async *hScanIterator(key, options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.hScan(key, cursor, options);
            cursor = reply.cursor;
            yield reply.entries;
        } while (cursor !== '0');
    }
    async *sScanIterator(key, options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.sScan(key, cursor, options);
            cursor = reply.cursor;
            yield reply.members;
        } while (cursor !== '0');
    }
    async *zScanIterator(key, options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.zScan(key, cursor, options);
            cursor = reply.cursor;
            yield reply.members;
        } while (cursor !== '0');
    }
    /**
     * @deprecated use .close instead
     */
    QUIT() {
        return this._socket.quit(async () => {
            clearTimeout(this._pingTimer);
            const quitPromise = this._queue.addCommand(['QUIT']);
            this._scheduleWrite();
            return quitPromise;
        });
    }
    quit = this.QUIT;
    /**
     * @deprecated use .destroy instead
     */
    disconnect() {
        return Promise.resolve(this.destroy());
    }
    /**
     * Close the client. Wait for pending commands.
     */
    close() {
        return new Promise(resolve => {
            clearTimeout(this._pingTimer);
            this._socket.close();
            if (this._queue.isEmpty()) {
                this._socket.destroySocket();
                return resolve();
            }
            const maybeClose = () => {
                if (!this._queue.isEmpty())
                    return;
                this._socket.off('data', maybeClose);
                this._socket.destroySocket();
                resolve();
            };
            this._socket.on('data', maybeClose);
        });
    }
    /**
     * Destroy the client. Rejects all commands immediately.
     */
    destroy() {
        clearTimeout(this._pingTimer);
        this._queue.flushAll(new errors_1.DisconnectsClientError());
        this._socket.destroy();
    }
    ref() {
        this._socket.ref();
    }
    unref() {
        this._socket.unref();
    }
}
exports.default = RedisClient;
