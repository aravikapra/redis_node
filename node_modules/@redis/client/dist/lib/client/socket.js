"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_events_1 = require("node:events");
const net = __importStar(require("node:net"));
const tls = __importStar(require("node:tls"));
const errors_1 = require("../errors");
const promises_1 = require("node:timers/promises");
class RedisSocket extends node_events_1.EventEmitter {
    static _initiateOptions(options) {
        options ??= {};
        if (!options.path) {
            options.port ??= 6379;
            options.host ??= 'localhost';
        }
        options.connectTimeout ??= 5000;
        options.keepAlive ??= 5000;
        options.noDelay ??= true;
        return options;
    }
    static _isTlsSocket(options) {
        return options.tls === true;
    }
    _initiator;
    _options;
    _socket;
    _isOpen = false;
    get isOpen() {
        return this._isOpen;
    }
    _isReady = false;
    get isReady() {
        return this._isReady;
    }
    _isSocketUnrefed = false;
    constructor(initiator, options) {
        super();
        this._initiator = initiator;
        this._options = RedisSocket._initiateOptions(options);
    }
    _reconnectStrategy(retries, cause) {
        if (this._options.reconnectStrategy === false) {
            return false;
        }
        else if (typeof this._options.reconnectStrategy === 'number') {
            return this._options.reconnectStrategy;
        }
        else if (this._options.reconnectStrategy) {
            try {
                const retryIn = this._options.reconnectStrategy(retries, cause);
                if (retryIn !== false && !(retryIn instanceof Error) && typeof retryIn !== 'number') {
                    throw new TypeError(`Reconnect strategy should return \`false | Error | number\`, got ${retryIn} instead`);
                }
                return retryIn;
            }
            catch (err) {
                this.emit('error', err);
            }
        }
        return Math.min(retries * 50, 500);
    }
    _shouldReconnect(retries, cause) {
        const retryIn = this._reconnectStrategy(retries, cause);
        if (retryIn === false) {
            this._isOpen = false;
            this.emit('error', cause);
            return cause;
        }
        else if (retryIn instanceof Error) {
            this._isOpen = false;
            this.emit('error', cause);
            return new errors_1.ReconnectStrategyError(retryIn, cause);
        }
        return retryIn;
    }
    async connect() {
        if (this._isOpen) {
            throw new Error('Socket already opened');
        }
        this._isOpen = true;
        return this._connect();
    }
    async _connect() {
        let retries = 0;
        do {
            try {
                this._socket = await this._createSocket();
                this.emit('connect');
                try {
                    await this._initiator();
                }
                catch (err) {
                    this._socket.destroy();
                    this._socket = undefined;
                    throw err;
                }
                this._isReady = true;
                this.emit('ready');
            }
            catch (err) {
                const retryIn = this._shouldReconnect(retries++, err);
                if (typeof retryIn !== 'number') {
                    throw retryIn;
                }
                this.emit('error', err);
                await (0, promises_1.setTimeout)(retryIn);
                this.emit('reconnecting');
            }
        } while (this._isOpen && !this._isReady);
    }
    _createSocket() {
        return new Promise((resolve, reject) => {
            const { connectEvent, socket } = RedisSocket._isTlsSocket(this._options) ?
                this._createTlsSocket() :
                this._createNetSocket();
            if (this._options.connectTimeout) {
                socket.setTimeout(this._options.connectTimeout, () => socket.destroy(new errors_1.ConnectionTimeoutError()));
            }
            if (this._isSocketUnrefed) {
                socket.unref();
            }
            socket
                .setNoDelay(this._options.noDelay)
                .once('error', reject)
                .once(connectEvent, () => {
                socket
                    .setTimeout(0)
                    // https://github.com/nodejs/node/issues/31663
                    .setKeepAlive(this._options.keepAlive !== false, this._options.keepAlive || 0)
                    .off('error', reject)
                    .once('error', (err) => this._onSocketError(err))
                    .once('close', hadError => {
                    if (!hadError && this._isOpen && this._socket === socket) {
                        this._onSocketError(new errors_1.SocketClosedUnexpectedlyError());
                    }
                })
                    .on('drain', () => this.emit('drain'))
                    .on('data', data => this.emit('data', data));
                resolve(socket);
            });
        });
    }
    _createNetSocket() {
        return {
            connectEvent: 'connect',
            socket: net.connect(this._options) // TODO
        };
    }
    _createTlsSocket() {
        return {
            connectEvent: 'secureConnect',
            socket: tls.connect(this._options) // TODO
        };
    }
    _onSocketError(err) {
        this._isReady = false;
        this.emit('error', err);
        if (!this._isOpen || typeof this._shouldReconnect(0, err) !== 'number')
            return;
        this.emit('reconnecting');
        this._connect().catch(() => {
            // the error was already emitted, silently ignore it
        });
    }
    write(iterator) {
        if (!this._socket)
            return;
        this._socket.cork();
        for (const args of iterator) {
            for (const toWrite of args) {
                this._socket.write(toWrite);
            }
            if (this._socket.writableNeedDrain)
                break;
        }
        this._socket.uncork();
    }
    async quit(fn) {
        if (!this._isOpen) {
            throw new errors_1.ClientClosedError();
        }
        this._isOpen = false;
        const reply = await fn();
        this.destroySocket();
        return reply;
    }
    close() {
        if (!this._isOpen) {
            throw new errors_1.ClientClosedError();
        }
        this._isOpen = false;
    }
    destroy() {
        if (!this._isOpen) {
            throw new errors_1.ClientClosedError();
        }
        this._isOpen = false;
        this.destroySocket();
    }
    destroySocket() {
        this._isReady = false;
        if (this._socket) {
            this._socket.destroy();
            this._socket = undefined;
        }
        this.emit('end');
    }
    ref() {
        this._isSocketUnrefed = false;
        this._socket?.ref();
    }
    unref() {
        this._isSocketUnrefed = true;
        this._socket?.unref();
    }
}
exports.default = RedisSocket;
