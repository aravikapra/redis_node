"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const linked_list_1 = require("./linked-list");
const encoder_1 = __importDefault(require("../RESP/encoder"));
const decoder_1 = require("../RESP/decoder");
const pub_sub_1 = require("./pub-sub");
const errors_1 = require("../errors");
const PONG = Buffer.from('pong');
const RESP2_PUSH_TYPE_MAPPING = {
    ...decoder_1.PUSH_TYPE_MAPPING,
    [decoder_1.RESP_TYPES.SIMPLE_STRING]: Buffer
};
class RedisCommandsQueue {
    _maxLength;
    _toWrite = new linked_list_1.DoublyLinkedList();
    _waitingForReply = new linked_list_1.SinglyLinkedList();
    _onShardedChannelMoved;
    _pubSub = new pub_sub_1.PubSub();
    get isPubSubActive() {
        return this._pubSub.isActive;
    }
    _chainInExecution;
    decoder;
    constructor(respVersion, maxLength, onShardedChannelMoved) {
        this.decoder = this._initiateDecoder(respVersion);
        this._maxLength = maxLength;
        this._onShardedChannelMoved = onShardedChannelMoved;
    }
    _initiateDecoder(respVersion) {
        return respVersion === 3 ?
            this._initiateResp3Decoder() :
            this._initiateResp2Decoder();
    }
    _onReply(reply) {
        this._waitingForReply.shift().resolve(reply);
    }
    _onErrorReply(err) {
        this._waitingForReply.shift().reject(err);
    }
    _onPush(push) {
        // TODO: type
        if (this._pubSub.handleMessageReply(push))
            return true;
        const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(push);
        if (isShardedUnsubscribe && !this._waitingForReply.length) {
            const channel = push[1].toString();
            this._onShardedChannelMoved(channel, this._pubSub.removeShardedListeners(channel));
            return true;
        }
        else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(push)) {
            const head = this._waitingForReply.head.value;
            if ((Number.isNaN(head.channelsCounter) && push[2] === 0) ||
                --head.channelsCounter === 0) {
                this._waitingForReply.shift().resolve();
            }
            return true;
        }
    }
    _getTypeMapping() {
        return this._waitingForReply.head.value.typeMapping ?? {};
    }
    _initiateResp3Decoder() {
        return new decoder_1.Decoder({
            onReply: reply => this._onReply(reply),
            onErrorReply: err => this._onErrorReply(err),
            onPush: push => {
                if (!this._onPush(push)) {
                }
            },
            getTypeMapping: () => this._getTypeMapping()
        });
    }
    _initiateResp2Decoder() {
        return new decoder_1.Decoder({
            onReply: reply => {
                if (this._pubSub.isActive && Array.isArray(reply)) {
                    if (this._onPush(reply))
                        return;
                    if (PONG.equals(reply[0])) {
                        const { resolve, typeMapping } = this._waitingForReply.shift(), buffer = (reply[1].length === 0 ? reply[0] : reply[1]);
                        resolve(typeMapping?.[decoder_1.RESP_TYPES.SIMPLE_STRING] === Buffer ? buffer : buffer.toString());
                        return;
                    }
                }
                this._onReply(reply);
            },
            onErrorReply: err => this._onErrorReply(err),
            // PUSH type does not exist in RESP2
            // PubSub is handled in onReply  
            // @ts-expect-error
            onPush: undefined,
            getTypeMapping: () => {
                // PubSub push is an Array in RESP2
                return this._pubSub.isActive ?
                    RESP2_PUSH_TYPE_MAPPING :
                    this._getTypeMapping();
            }
        });
    }
    addCommand(args, options) {
        if (this._maxLength && this._toWrite.length + this._waitingForReply.length >= this._maxLength) {
            return Promise.reject(new Error('The queue is full'));
        }
        else if (options?.abortSignal?.aborted) {
            return Promise.reject(new errors_1.AbortError());
        }
        return new Promise((resolve, reject) => {
            let node;
            const value = {
                args,
                chainId: options?.chainId,
                typeMapping: options?.typeMapping,
                resolve,
                reject,
                abort: undefined
            };
            const signal = options?.abortSignal;
            if (signal) {
                value.abort = {
                    signal,
                    listener: () => {
                        this._toWrite.remove(node);
                        value.reject(new errors_1.AbortError());
                    }
                };
                signal.addEventListener('abort', value.abort.listener, { once: true });
            }
            node = options?.asap ?
                this._toWrite.unshift(value) :
                this._toWrite.push(value);
        });
    }
    subscribe(type, channels, listener, returnBuffers) {
        return this._pushPubSubCommand(this._pubSub.subscribe(type, channels, listener, returnBuffers));
    }
    unsubscribe(type, channels, listener, returnBuffers) {
        return this._pushPubSubCommand(this._pubSub.unsubscribe(type, channels, listener, returnBuffers));
    }
    resubscribe() {
        const commands = this._pubSub.resubscribe();
        if (!commands.length)
            return;
        return Promise.all(commands.map(command => this._pushPubSubCommand(command)));
    }
    extendPubSubChannelListeners(type, channel, listeners) {
        return this._pushPubSubCommand(this._pubSub.extendChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
        return this._pushPubSubCommand(this._pubSub.extendTypeListeners(type, listeners));
    }
    getPubSubListeners(type) {
        return this._pubSub.getTypeListeners(type);
    }
    _pushPubSubCommand(command) {
        if (command === undefined)
            return;
        return new Promise((resolve, reject) => {
            this._toWrite.push({
                args: command.args,
                channelsCounter: command.channelsCounter,
                typeMapping: decoder_1.PUSH_TYPE_MAPPING,
                resolve: () => {
                    command.resolve();
                    resolve();
                },
                reject: err => {
                    command.reject?.();
                    reject(err);
                }
            });
        });
    }
    isWaitingToWrite() {
        return this._toWrite.length > 0;
    }
    *commandsToWrite() {
        let toSend = this._toWrite.shift();
        while (toSend) {
            let encoded;
            try {
                encoded = (0, encoder_1.default)(toSend.args);
            }
            catch (err) {
                toSend.reject(err);
                toSend = this._toWrite.shift();
                continue;
            }
            if (toSend.abort) {
                RedisCommandsQueue._removeAbortListener(toSend);
                toSend.abort = undefined;
            }
            // TODO reuse `toSend` or create new object?
            toSend.args = undefined;
            toSend.chainId = undefined;
            this._waitingForReply.push(toSend);
            this._chainInExecution = toSend.chainId;
            yield encoded;
            toSend = this._toWrite.shift();
        }
    }
    _flushWaitingForReply(err) {
        for (const node of this._waitingForReply) {
            node.reject(err);
        }
        this._waitingForReply.reset();
    }
    static _removeAbortListener(command) {
        command.abort.signal.removeEventListener('abort', command.abort.listener);
    }
    static _flushToWrite(toBeSent, err) {
        if (toBeSent.abort) {
            RedisCommandsQueue._removeAbortListener(toBeSent);
        }
        toBeSent.reject(err);
    }
    flushWaitingForReply(err) {
        this.decoder.reset();
        this._pubSub.reset();
        this._flushWaitingForReply(err);
        if (!this._chainInExecution)
            return;
        while (this._toWrite.head?.value.chainId === this._chainInExecution) {
            RedisCommandsQueue._flushToWrite(this._toWrite.shift(), err);
        }
        this._chainInExecution = undefined;
    }
    flushAll(err) {
        this.decoder.reset();
        this._pubSub.reset();
        this._flushWaitingForReply(err);
        for (const node of this._toWrite) {
            RedisCommandsQueue._flushToWrite(node, err);
        }
        this._toWrite.reset();
    }
    isEmpty() {
        return (this._toWrite.length === 0 &&
            this._waitingForReply.length === 0);
    }
}
exports.default = RedisCommandsQueue;
