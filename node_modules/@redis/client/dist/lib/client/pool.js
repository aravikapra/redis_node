"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisClientPool = void 0;
const commands_1 = __importDefault(require("../commands"));
const _1 = __importDefault(require("."));
const node_events_1 = require("node:events");
const linked_list_1 = require("./linked-list");
const errors_1 = require("../errors");
const commander_1 = require("../commander");
class RedisClientPool extends node_events_1.EventEmitter {
    static _createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function (...args) {
            const redisArgs = command.transformArguments(...args), reply = await this.sendCommand(redisArgs, this._commandOptions);
            return transformReply ?
                transformReply(reply, redisArgs.preserve) :
                reply;
        };
    }
    static _createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function (...args) {
            const redisArgs = command.transformArguments(...args), reply = await this.self.sendCommand(redisArgs, this.self._commandOptions);
            return transformReply ?
                transformReply(reply, redisArgs.preserve) :
                reply;
        };
    }
    static _createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn), transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return async function (...args) {
            const fnArgs = fn.transformArguments(...args), reply = await this.self.sendCommand(prefix.concat(fnArgs), this.self._commandOptions);
            return transformReply ?
                transformReply(reply, fnArgs.preserve) :
                reply;
        };
    }
    static _createScriptCommand(script, resp) {
        const prefix = (0, commander_1.scriptArgumentsPrefix)(script), transformReply = (0, commander_1.getTransformReply)(script, resp);
        return async function (...args) {
            const scriptArgs = script.transformArguments(...args), redisArgs = prefix.concat(scriptArgs), reply = await this.executeScript(script, redisArgs, this._commandOptions);
            return transformReply ?
                transformReply(reply, scriptArgs.preserve) :
                reply;
        };
    }
    static create(
    // clientFactory: () => RedisClientType<M, F, S, RESP, TYPE_MAPPING>,
    clientOptions, options) {
        // @ts-ignore
        const Pool = (0, commander_1.attachConfig)({
            BaseClass: RedisClientPool,
            commands: commands_1.default,
            createCommand: RedisClientPool._createCommand,
            createModuleCommand: RedisClientPool._createModuleCommand,
            createFunctionCommand: RedisClientPool._createFunctionCommand,
            createScriptCommand: RedisClientPool._createScriptCommand,
            config: clientOptions
        });
        // returning a "proxy" to prevent the namespaces.self to leak between "proxies"
        return Object.create(new Pool(_1.default.factory(clientOptions).bind(undefined, clientOptions), options));
    }
    // TODO: defaults
    static _DEFAULTS = {
        minimum: 1,
        maximum: 100,
        acquireTimeout: 3000,
        cleanupDelay: 3000
    };
    _clientFactory;
    _options;
    _idleClients = new linked_list_1.SinglyLinkedList();
    /**
     * The number of idle clients.
     */
    get idleClients() {
        return this._idleClients.length;
    }
    _clientsInUse = new linked_list_1.DoublyLinkedList();
    /**
     * The number of clients in use.
     */
    get clientsInUse() {
        return this._clientsInUse.length;
    }
    _connectingClients = 0;
    /**
     * The number of clients that are currently connecting.
     */
    get connectingClients() {
        return this._connectingClients;
    }
    /**
     * The total number of clients in the pool (including connecting, idle, and in use).
     */
    get totalClients() {
        return this._idleClients.length + this._clientsInUse.length;
    }
    _tasksQueue = new linked_list_1.SinglyLinkedList();
    /**
     * The number of tasks waiting for a client to become available.
     */
    get tasksQueueLength() {
        return this._tasksQueue.length;
    }
    _isOpen = false;
    /**
     * Whether the pool is open (either connecting or connected).
     */
    get isOpen() {
        return this._isOpen;
    }
    _isClosing = false;
    /**
     * Whether the pool is closing (*not* closed).
     */
    get isClosing() {
        return this._isClosing;
    }
    /**
     * You are probably looking for {@link RedisClient.createPool `RedisClient.createPool`},
     * {@link RedisClientPool.fromClient `RedisClientPool.fromClient`},
     * or {@link RedisClientPool.fromOptions `RedisClientPool.fromOptions`}...
     */
    constructor(clientFactory, options) {
        super();
        this._clientFactory = clientFactory;
        this._options = {
            ...RedisClientPool._DEFAULTS,
            ...options
        };
    }
    _self = this;
    _commandOptions;
    withCommandOptions(options) {
        const proxy = Object.create(this._self);
        proxy._commandOptions = options;
        return proxy;
    }
    _commandOptionsProxy(key, value) {
        const proxy = Object.create(this._self);
        proxy._commandOptions = Object.create(this._commandOptions ?? null);
        proxy._commandOptions[key] = value;
        return proxy;
    }
    /**
     * Override the `typeMapping` command option
     */
    withTypeMapping(typeMapping) {
        return this._commandOptionsProxy('typeMapping', typeMapping);
    }
    /**
     * Override the `abortSignal` command option
     */
    withAbortSignal(abortSignal) {
        return this._commandOptionsProxy('abortSignal', abortSignal);
    }
    /**
     * Override the `asap` command option to `true`
     * TODO: remove?
     */
    asap() {
        return this._commandOptionsProxy('asap', true);
    }
    async connect() {
        if (this._isOpen)
            return; // TODO: throw error?
        this._isOpen = true;
        const promises = [];
        while (promises.length < this._options.minimum) {
            promises.push(this._create());
        }
        try {
            await Promise.all(promises);
            return this;
        }
        catch (err) {
            this.destroy();
            throw err;
        }
    }
    async _create() {
        const node = this._clientsInUse.push(this._clientFactory()
            .on('error', (err) => this.emit('error', err)));
        try {
            await node.value.connect();
        }
        catch (err) {
            this._clientsInUse.remove(node);
            throw err;
        }
        this._returnClient(node);
    }
    execute(fn) {
        return new Promise((resolve, reject) => {
            const client = this._idleClients.shift(), { tail } = this._tasksQueue;
            if (!client) {
                let timeout;
                if (this._options.acquireTimeout > 0) {
                    timeout = setTimeout(() => {
                        this._tasksQueue.remove(task, tail);
                        reject(new errors_1.TimeoutError('Timeout waiting for a client')); // TODO: message
                    }, this._options.acquireTimeout);
                }
                const task = this._tasksQueue.push({
                    timeout,
                    // @ts-ignore
                    resolve,
                    reject,
                    fn
                });
                if (this.totalClients < this._options.maximum) {
                    this._create();
                }
                return;
            }
            const node = this._clientsInUse.push(client);
            // @ts-ignore
            this._executeTask(node, resolve, reject, fn);
        });
    }
    _executeTask(node, resolve, reject, fn) {
        const result = fn(node.value);
        if (result instanceof Promise) {
            result.then(resolve, reject);
            result.finally(() => this._returnClient(node));
        }
        else {
            resolve(result);
            this._returnClient(node);
        }
    }
    _returnClient(node) {
        const task = this._tasksQueue.shift();
        if (task) {
            this._executeTask(node, task.resolve, task.reject, task.fn);
            return;
        }
        this._clientsInUse.remove(node);
        this._idleClients.push(node.value);
        this._scheduleCleanup();
    }
    cleanupTimeout;
    _scheduleCleanup() {
        if (this.totalClients <= this._options.minimum)
            return;
        clearTimeout(this.cleanupTimeout);
        this.cleanupTimeout = setTimeout(() => this._cleanup(), this._options.cleanupDelay);
    }
    _cleanup() {
        const toDestroy = Math.min(this._idleClients.length, this.totalClients - this._options.minimum);
        for (let i = 0; i < toDestroy; i++) {
            // TODO: shift vs pop
            this._idleClients.shift().destroy();
        }
    }
    sendCommand(args, options) {
        return this.execute(client => client.sendCommand(args, options));
    }
    executeScript(script, args, options) {
        return this.execute(client => client.executeScript(script, args, options));
    }
    async close() {
        if (this._isClosing)
            return; // TODO: throw err?
        if (!this._isOpen)
            return; // TODO: throw err?
        this._isClosing = true;
        try {
            const promises = [];
            for (const client of this._idleClients) {
                promises.push(client.close());
            }
            for (const client of this._clientsInUse) {
                promises.push(client.close());
            }
            await Promise.all(promises);
            this._idleClients.reset();
            this._clientsInUse.reset();
        }
        catch (err) {
        }
        finally {
            this._isClosing = false;
        }
    }
    destroy() {
        for (const client of this._idleClients) {
            client.destroy();
        }
        this._idleClients.reset();
        for (const client of this._clientsInUse) {
            client.destroy();
        }
        this._clientsInUse.reset();
        this._isOpen = false;
    }
}
exports.RedisClientPool = RedisClientPool;
