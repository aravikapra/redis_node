"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = __importDefault(require("../commands"));
const multi_command_1 = __importDefault(require("../multi-command"));
const commander_1 = require("../commander");
const _1 = __importDefault(require("."));
class RedisClusterMultiCommand {
    static _createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return function (...args) {
            const redisArgs = command.transformArguments(...args), firstKey = _1.default.extractFirstKey(command, args, redisArgs);
            return this.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
        };
    }
    static _createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return function (...args) {
            const redisArgs = command.transformArguments(...args), firstKey = _1.default.extractFirstKey(command, args, redisArgs);
            return this.self.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
        };
    }
    static _createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn), transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return function (...args) {
            const fnArgs = fn.transformArguments(...args), redisArgs = prefix.concat(fnArgs), firstKey = _1.default.extractFirstKey(fn, args, fnArgs);
            redisArgs.preserve = fnArgs.preserve;
            return this.self.addCommand(firstKey, fn.IS_READ_ONLY, redisArgs, transformReply);
        };
    }
    static _createScriptCommand(script, resp) {
        const transformReply = (0, commander_1.getTransformReply)(script, resp);
        return function (...args) {
            const scriptArgs = script.transformArguments(...args);
            this._setState(_1.default.extractFirstKey(script, args, scriptArgs), script.IS_READ_ONLY);
            this._multi.addScript(script, scriptArgs, transformReply);
            return this;
        };
    }
    static extend(config) {
        return (0, commander_1.attachConfig)({
            BaseClass: RedisClusterMultiCommand,
            commands: commands_1.default,
            createCommand: RedisClusterMultiCommand._createCommand,
            createModuleCommand: RedisClusterMultiCommand._createModuleCommand,
            createFunctionCommand: RedisClusterMultiCommand._createFunctionCommand,
            createScriptCommand: RedisClusterMultiCommand._createScriptCommand,
            config
        });
    }
    _multi = new multi_command_1.default();
    _cluster;
    _firstKey;
    _isReadonly = true;
    constructor(cluster, routing) {
        this._cluster = cluster;
        this._firstKey = routing;
    }
    _setState(firstKey, isReadonly) {
        this._firstKey ??= firstKey;
        this._isReadonly &&= isReadonly;
    }
    addCommand(firstKey, isReadonly, args, transformReply) {
        this._setState(firstKey, isReadonly);
        this._multi.addCommand(args, transformReply);
        return this;
    }
    async exec(execAsPipeline = false) {
        if (execAsPipeline)
            return this.execAsPipeline();
        return this._multi.transformReplies(await this._cluster._executeMulti(this._firstKey, this._isReadonly, this._multi.queue));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
        return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
        if (this._multi.queue.length === 0)
            return [];
        return this._multi.transformReplies(await this._cluster._executePipeline(this._firstKey, this._isReadonly, this._multi.queue));
    }
    execAsPipelineTyped() {
        return this.execAsPipeline();
    }
}
exports.default = RedisClusterMultiCommand;
