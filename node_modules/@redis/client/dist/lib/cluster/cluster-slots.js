"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const client_1 = __importDefault(require("../client"));
const pub_sub_1 = require("../client/pub-sub");
const cluster_key_slot_1 = __importDefault(require("cluster-key-slot"));
class RedisClusterSlots {
    static _SLOTS = 16384;
    _options;
    _clientFactory;
    _emit;
    slots = new Array(RedisClusterSlots._SLOTS);
    masters = new Array();
    replicas = new Array();
    nodeByAddress = new Map();
    pubSubNode;
    _isOpen = false;
    get isOpen() {
        return this._isOpen;
    }
    constructor(options, emit) {
        this._options = options;
        this._clientFactory = client_1.default.factory(options);
        this._emit = emit;
    }
    async connect() {
        if (this._isOpen) {
            throw new Error('Cluster already open');
        }
        this._isOpen = true;
        try {
            await this._discoverWithRootNodes();
        }
        catch (err) {
            this._isOpen = false;
            throw err;
        }
    }
    async _discoverWithRootNodes() {
        let start = Math.floor(Math.random() * this._options.rootNodes.length);
        for (let i = start; i < this._options.rootNodes.length; i++) {
            if (!this._isOpen)
                throw new Error('Cluster closed');
            if (await this._discover(this._options.rootNodes[i]))
                return;
        }
        for (let i = 0; i < start; i++) {
            if (!this._isOpen)
                throw new Error('Cluster closed');
            if (await this._discover(this._options.rootNodes[i]))
                return;
        }
        throw new errors_1.RootNodesUnavailableError();
    }
    _resetSlots() {
        this.slots = new Array(RedisClusterSlots._SLOTS);
        this.masters = [];
        this.replicas = [];
        this._randomNodeIterator = undefined;
    }
    async _discover(rootNode) {
        this._resetSlots();
        try {
            const addressesInUse = new Set(), promises = [], eagerConnect = this._options.minimizeConnections !== true;
            for (const { from, to, master, replicas } of await this._getShards(rootNode)) {
                const shard = {
                    master: this._initiateSlotNode(master, false, eagerConnect, addressesInUse, promises)
                };
                if (this._options.useReplicas) {
                    shard.replicas = replicas.map(replica => this._initiateSlotNode(replica, true, eagerConnect, addressesInUse, promises));
                }
                for (let i = from; i <= to; i++) {
                    this.slots[i] = shard;
                }
            }
            if (this.pubSubNode && !addressesInUse.has(this.pubSubNode.address)) {
                const channelsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PubSubType.CHANNELS), patternsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PubSubType.PATTERNS);
                this.pubSubNode.client.destroy();
                if (channelsListeners.size || patternsListeners.size) {
                    promises.push(this._initiatePubSubClient({
                        [pub_sub_1.PubSubType.CHANNELS]: channelsListeners,
                        [pub_sub_1.PubSubType.PATTERNS]: patternsListeners
                    }));
                }
            }
            for (const [address, node] of this.nodeByAddress.entries()) {
                if (addressesInUse.has(address))
                    continue;
                if (node.client) {
                    node.client.destroy();
                }
                const { pubSub } = node;
                if (pubSub) {
                    pubSub.client.destroy();
                }
                this.nodeByAddress.delete(address);
            }
            await Promise.all(promises);
            return true;
        }
        catch (err) {
            this._emit('error', err);
            return false;
        }
    }
    async _getShards(rootNode) {
        const options = this._clientOptionsDefaults(rootNode);
        options.socket ??= {};
        options.socket.reconnectStrategy = false;
        options.RESP = this._options.RESP;
        options.commandOptions = undefined;
        // TODO: find a way to avoid type casting
        const client = await this._clientFactory(options)
            .on('error', err => this._emit('error', err))
            .connect();
        try {
            // switch to `CLUSTER SHARDS` when Redis 7.0 will be the minimum supported version
            return await client.clusterSlots();
        }
        finally {
            client.destroy();
        }
    }
    _getNodeAddress(address) {
        switch (typeof this._options.nodeAddressMap) {
            case 'object':
                return this._options.nodeAddressMap[address];
            case 'function':
                return this._options.nodeAddressMap(address);
        }
    }
    _clientOptionsDefaults(options) {
        if (!this._options.defaults)
            return options;
        let socket;
        if (this._options.defaults.socket) {
            socket = options?.socket ? {
                ...this._options.defaults.socket,
                ...options.socket
            } : this._options.defaults.socket;
        }
        else {
            socket = options?.socket;
        }
        return {
            ...this._options.defaults,
            ...options,
            socket
        };
    }
    _initiateSlotNode(shard, readonly, eagerConnent, addressesInUse, promises) {
        const address = `${shard.host}:${shard.port}`;
        let node = this.nodeByAddress.get(address);
        if (!node) {
            node = {
                ...shard,
                address,
                readonly,
                client: undefined,
                connectPromise: undefined
            };
            if (eagerConnent) {
                promises.push(this._createNodeClient(node));
            }
            this.nodeByAddress.set(address, node);
        }
        if (!addressesInUse.has(address)) {
            addressesInUse.add(address);
            (readonly ? this.replicas : this.masters).push(node);
        }
        return node;
    }
    _createClient(node, readonly = node.readonly) {
        return this._clientFactory(this._clientOptionsDefaults({
            socket: this._getNodeAddress(node.address) ?? {
                host: node.host,
                port: node.port
            },
            readonly,
            RESP: this._options.RESP
        })).on('error', err => console.error(err));
    }
    _createNodeClient(node, readonly) {
        const client = node.client = this._createClient(node, readonly);
        return node.connectPromise = client.connect()
            .finally(() => node.connectPromise = undefined);
    }
    nodeClient(node) {
        return (node.connectPromise ?? // if the node is connecting
            node.client ?? // if the node is connected
            this._createNodeClient(node) // if the not is disconnected
        );
    }
    _runningRediscoverPromise;
    async rediscover(startWith) {
        this._runningRediscoverPromise ??= this._rediscover(startWith)
            .finally(() => this._runningRediscoverPromise = undefined);
        return this._runningRediscoverPromise;
    }
    async _rediscover(startWith) {
        if (await this._discover(startWith.options))
            return;
        return this._discoverWithRootNodes();
    }
    /**
     * @deprecated Use `close` instead.
     */
    quit() {
        return this._destroy(client => client.quit());
    }
    /**
     * @deprecated Use `destroy` instead.
     */
    disconnect() {
        return this._destroy(client => client.disconnect());
    }
    close() {
        return this._destroy(client => client.close());
    }
    destroy() {
        this._isOpen = false;
        for (const client of this._clients()) {
            client.destroy();
        }
        if (this.pubSubNode) {
            this.pubSubNode.client.destroy();
            this.pubSubNode = undefined;
        }
        this._resetSlots();
        this.nodeByAddress.clear();
    }
    *_clients() {
        for (const master of this.masters) {
            if (master.client) {
                yield master.client;
            }
            if (master.pubSub) {
                yield master.pubSub.client;
            }
        }
        for (const replica of this.replicas) {
            if (replica.client) {
                yield replica.client;
            }
        }
    }
    async _destroy(fn) {
        this._isOpen = false;
        const promises = [];
        for (const client of this._clients()) {
            promises.push(fn(client));
        }
        if (this.pubSubNode) {
            promises.push(fn(this.pubSubNode.client));
            this.pubSubNode = undefined;
        }
        this._resetSlots();
        this.nodeByAddress.clear();
        await Promise.allSettled(promises);
    }
    getClient(firstKey, isReadonly) {
        if (!firstKey) {
            return this.nodeClient(this.getRandomNode());
        }
        const slotNumber = (0, cluster_key_slot_1.default)(firstKey);
        if (!isReadonly) {
            return this.nodeClient(this.slots[slotNumber].master);
        }
        return this.nodeClient(this.getSlotRandomNode(slotNumber));
    }
    *_iterateAllNodes() {
        let i = Math.floor(Math.random() * (this.masters.length + this.replicas.length));
        if (i < this.masters.length) {
            do {
                yield this.masters[i];
            } while (++i < this.masters.length);
            for (const replica of this.replicas) {
                yield replica;
            }
        }
        else {
            i -= this.masters.length;
            do {
                yield this.replicas[i];
            } while (++i < this.replicas.length);
        }
        while (true) {
            for (const master of this.masters) {
                yield master;
            }
            for (const replica of this.replicas) {
                yield replica;
            }
        }
    }
    _randomNodeIterator;
    getRandomNode() {
        this._randomNodeIterator ??= this._iterateAllNodes();
        return this._randomNodeIterator.next().value;
    }
    *_slotNodesIterator(slot) {
        let i = Math.floor(Math.random() * (1 + slot.replicas.length));
        if (i < slot.replicas.length) {
            do {
                yield slot.replicas[i];
            } while (++i < slot.replicas.length);
        }
        while (true) {
            yield slot.master;
            for (const replica of slot.replicas) {
                yield replica;
            }
        }
    }
    getSlotRandomNode(slotNumber) {
        const slot = this.slots[slotNumber];
        if (!slot.replicas?.length) {
            return slot.master;
        }
        slot.nodesIterator ??= this._slotNodesIterator(slot);
        return slot.nodesIterator.next().value;
    }
    getMasterByAddress(address) {
        const master = this.nodeByAddress.get(address);
        if (!master)
            return;
        return this.nodeClient(master);
    }
    getPubSubClient() {
        if (!this.pubSubNode)
            return this._initiatePubSubClient();
        return this.pubSubNode.connectPromise ?? this.pubSubNode.client;
    }
    async _initiatePubSubClient(toResubscribe) {
        const index = Math.floor(Math.random() * (this.masters.length + this.replicas.length)), node = index < this.masters.length ?
            this.masters[index] :
            this.replicas[index - this.masters.length], client = this._createClient(node, true);
        this.pubSubNode = {
            address: node.address,
            client,
            connectPromise: client.connect()
                .then(async (client) => {
                if (toResubscribe) {
                    await Promise.all([
                        client.extendPubSubListeners(pub_sub_1.PubSubType.CHANNELS, toResubscribe[pub_sub_1.PubSubType.CHANNELS]),
                        client.extendPubSubListeners(pub_sub_1.PubSubType.PATTERNS, toResubscribe[pub_sub_1.PubSubType.PATTERNS])
                    ]);
                }
                this.pubSubNode.connectPromise = undefined;
                return client;
            })
                .catch(err => {
                this.pubSubNode = undefined;
                throw err;
            })
        };
        return this.pubSubNode.connectPromise;
    }
    async executeUnsubscribeCommand(unsubscribe) {
        const client = await this.getPubSubClient();
        await unsubscribe(client);
        if (!client.isPubSubActive) {
            client.destroy();
            this.pubSubNode = undefined;
        }
    }
    getShardedPubSubClient(channel) {
        const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
        if (!master.pubSub)
            return this._initiateShardedPubSubClient(master);
        return master.pubSub.connectPromise ?? master.pubSub.client;
    }
    async _initiateShardedPubSubClient(master) {
        const client = this._createClient(master, true)
            .on('server-sunsubscribe', async (channel, listeners) => {
            try {
                await this.rediscover(client);
                const redirectTo = await this.getShardedPubSubClient(channel);
                await redirectTo.extendPubSubChannelListeners(pub_sub_1.PubSubType.SHARDED, channel, listeners);
            }
            catch (err) {
                this._emit('sharded-shannel-moved-error', err, channel, listeners);
            }
        });
        master.pubSub = {
            client,
            connectPromise: client.connect()
                .then(client => {
                master.pubSub.connectPromise = undefined;
                return client;
            })
                .catch(err => {
                master.pubSub = undefined;
                throw err;
            })
        };
        return master.pubSub.connectPromise;
    }
    async executeShardedUnsubscribeCommand(channel, unsubscribe) {
        const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
        if (!master.pubSub)
            return;
        const client = master.pubSub.connectPromise ?
            await master.pubSub.connectPromise :
            master.pubSub.client;
        await unsubscribe(client);
        if (!client.isPubSubActive) {
            client.destroy();
            master.pubSub = undefined;
        }
    }
}
exports.default = RedisClusterSlots;
