"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = __importDefault(require("../commands"));
const node_events_1 = require("node:events");
const commander_1 = require("../commander");
const cluster_slots_1 = __importDefault(require("./cluster-slots"));
const multi_command_1 = __importDefault(require("./multi-command"));
const errors_1 = require("../errors");
class RedisCluster extends node_events_1.EventEmitter {
    static extractFirstKey(command, args, redisArgs) {
        let key;
        switch (typeof command.FIRST_KEY_INDEX) {
            case 'number':
                key = redisArgs[command.FIRST_KEY_INDEX];
                break;
            case 'function':
                key = command.FIRST_KEY_INDEX(...args);
                break;
        }
        // TODO: remove once request & response policies are ready
        if (key === undefined && !command.IS_FORWARD_COMMAND) {
            throw new Error('TODO');
        }
        return key;
    }
    static _createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function (...args) {
            const redisArgs = command.transformArguments(...args), firstKey = RedisCluster.extractFirstKey(command, args, redisArgs), reply = await this.sendCommand(firstKey, command.IS_READ_ONLY, redisArgs, this._commandOptions);
            return transformReply ?
                transformReply(reply, redisArgs.preserve) :
                reply;
        };
    }
    static _createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function (...args) {
            const redisArgs = command.transformArguments(...args), firstKey = RedisCluster.extractFirstKey(command, args, redisArgs), reply = await this.self.sendCommand(firstKey, command.IS_READ_ONLY, redisArgs, this.self._commandOptions);
            return transformReply ?
                transformReply(reply, redisArgs.preserve) :
                reply;
        };
    }
    static _createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn), transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return async function (...args) {
            const fnArgs = fn.transformArguments(...args), firstKey = RedisCluster.extractFirstKey(fn, args, fnArgs), redisArgs = prefix.concat(fnArgs), reply = await this.self.sendCommand(firstKey, fn.IS_READ_ONLY, redisArgs, this.self._commandOptions);
            return transformReply ?
                transformReply(reply, fnArgs.preserve) :
                reply;
        };
    }
    static _createScriptCommand(script, resp) {
        const prefix = (0, commander_1.scriptArgumentsPrefix)(script), transformReply = (0, commander_1.getTransformReply)(script, resp);
        return async function (...args) {
            const scriptArgs = script.transformArguments(...args), firstKey = RedisCluster.extractFirstKey(script, args, scriptArgs), redisArgs = prefix.concat(scriptArgs), reply = await this.executeScript(script, firstKey, script.IS_READ_ONLY, redisArgs, this._commandOptions);
            return transformReply ?
                transformReply(reply, scriptArgs.preserve) :
                reply;
        };
    }
    static factory(config) {
        const Cluster = (0, commander_1.attachConfig)({
            BaseClass: RedisCluster,
            commands: commands_1.default,
            createCommand: RedisCluster._createCommand,
            createModuleCommand: RedisCluster._createModuleCommand,
            createFunctionCommand: RedisCluster._createFunctionCommand,
            createScriptCommand: RedisCluster._createScriptCommand,
            config
        });
        Cluster.prototype.Multi = multi_command_1.default.extend(config);
        return (options) => {
            // returning a "proxy" to prevent the namespaces.self to leak between "proxies"
            return Object.create(new Cluster(options));
        };
    }
    static create(options) {
        return RedisCluster.factory(options)(options);
    }
    _options;
    _slots;
    _commandOptions;
    /**
     * An array of the cluster slots, each slot contain its `master` and `replicas`.
     * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific node (master or replica).
     */
    get slots() {
        return this._slots.slots;
    }
    /**
     * An array of the cluster masters.
     * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific master node.
     */
    get masters() {
        return this._slots.masters;
    }
    /**
     * An array of the cluster replicas.
     * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific replica node.
     */
    get replicas() {
        return this._slots.replicas;
    }
    /**
     * A map form a node address (`<host>:<port>`) to its shard, each shard contain its `master` and `replicas`.
     * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific node (master or replica).
     */
    get nodeByAddress() {
        return this._slots.nodeByAddress;
    }
    /**
     * The current pub/sub node.
     */
    get pubSubNode() {
        return this._slots.pubSubNode;
    }
    get isOpen() {
        return this._slots.isOpen;
    }
    constructor(options) {
        super();
        this._options = options;
        this._slots = new cluster_slots_1.default(options, this.emit.bind(this));
        if (options?.commandOptions) {
            this._commandOptions = options.commandOptions;
        }
    }
    duplicate(overrides) {
        return new (Object.getPrototypeOf(this).constructor)({
            ...this._options,
            commandOptions: this._commandOptions,
            ...overrides
        });
    }
    connect() {
        return this._slots.connect();
    }
    withCommandOptions(options) {
        const proxy = Object.create(this);
        proxy._commandOptions = options;
        return proxy;
    }
    _commandOptionsProxy(key, value) {
        const proxy = Object.create(this);
        proxy._commandOptions = Object.create(this._commandOptions ?? null);
        proxy._commandOptions[key] = value;
        return proxy;
    }
    /**
     * Override the `typeMapping` command option
     */
    withTypeMapping(typeMapping) {
        return this._commandOptionsProxy('typeMapping', typeMapping);
    }
    // /**
    //  * Override the `policies` command option
    //  * TODO
    //  */
    // withPolicies<POLICIES extends CommandPolicies> (policies: POLICIES) {
    //   return this._commandOptionsProxy('policies', policies);
    // }
    async _execute(firstKey, isReadonly, fn) {
        const maxCommandRedirections = this._options.maxCommandRedirections ?? 16;
        let client = await this._slots.getClient(firstKey, isReadonly), i = 0;
        while (true) {
            try {
                return await fn(client);
            }
            catch (err) {
                // TODO: error class
                if (++i > maxCommandRedirections || !(err instanceof Error)) {
                    throw err;
                }
                if (err.message.startsWith('ASK')) {
                    const address = err.message.substring(err.message.lastIndexOf(' ') + 1);
                    let redirectTo = await this._slots.getMasterByAddress(address);
                    if (!redirectTo) {
                        await this._slots.rediscover(client);
                        redirectTo = await this._slots.getMasterByAddress(address);
                    }
                    if (!redirectTo) {
                        throw new Error(`Cannot find node ${address}`);
                    }
                    await redirectTo.asking();
                    client = redirectTo;
                    continue;
                }
                if (err.message.startsWith('MOVED')) {
                    await this._slots.rediscover(client);
                    client = await this._slots.getClient(firstKey, isReadonly);
                    continue;
                }
                throw err;
            }
        }
    }
    async sendCommand(firstKey, isReadonly, args, options) {
        return this._execute(firstKey, isReadonly, client => client.sendCommand(args, options));
    }
    executeScript(script, firstKey, isReadonly, args, options) {
        return this._execute(firstKey, isReadonly, client => client.executeScript(script, args, options));
    }
    /**
     * @internal
     */
    async _executePipeline(firstKey, isReadonly, commands) {
        const client = await this._slots.getClient(firstKey, isReadonly);
        return client._executePipeline(commands);
    }
    /**
     * @internal
     */
    async _executeMulti(firstKey, isReadonly, commands) {
        const client = await this._slots.getClient(firstKey, isReadonly);
        return client._executeMulti(commands);
    }
    MULTI(routing) {
        return new this.Multi(this, routing);
    }
    multi = this.MULTI;
    async SUBSCRIBE(channels, listener, bufferMode) {
        return (await this._slots.getPubSubClient())
            .SUBSCRIBE(channels, listener, bufferMode);
    }
    subscribe = this.SUBSCRIBE;
    async UNSUBSCRIBE(channels, listener, bufferMode) {
        return this._slots.executeUnsubscribeCommand(client => client.UNSUBSCRIBE(channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    async PSUBSCRIBE(patterns, listener, bufferMode) {
        return (await this._slots.getPubSubClient())
            .PSUBSCRIBE(patterns, listener, bufferMode);
    }
    pSubscribe = this.PSUBSCRIBE;
    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
        return this._slots.executeUnsubscribeCommand(client => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    async SSUBSCRIBE(channels, listener, bufferMode) {
        const maxCommandRedirections = this._options.maxCommandRedirections ?? 16, firstChannel = Array.isArray(channels) ? channels[0] : channels;
        let client = await this._slots.getShardedPubSubClient(firstChannel);
        for (let i = 0;; i++) {
            try {
                return await client.SSUBSCRIBE(channels, listener, bufferMode);
            }
            catch (err) {
                if (++i > maxCommandRedirections || !(err instanceof errors_1.ErrorReply)) {
                    throw err;
                }
                if (err.message.startsWith('MOVED')) {
                    await this._slots.rediscover(client);
                    client = await this._slots.getShardedPubSubClient(firstChannel);
                    continue;
                }
                throw err;
            }
        }
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
        return this._slots.executeShardedUnsubscribeCommand(Array.isArray(channels) ? channels[0] : channels, client => client.SUNSUBSCRIBE(channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    /**
     * @deprecated Use `close` instead.
     */
    quit() {
        return this._slots.quit();
    }
    /**
     * @deprecated Use `destroy` instead.
     */
    disconnect() {
        return this._slots.disconnect();
    }
    close() {
        return this._slots.close();
    }
    destroy() {
        return this._slots.destroy();
    }
    nodeClient(node) {
        return this._slots.nodeClient(node);
    }
    /**
     * Returns a random node from the cluster.
     * Userful for running "forward" commands (like PUBLISH) on a random node.
     */
    getRandomNode() {
        return this._slots.getRandomNode();
    }
    /**
     * Get a random node from a slot.
     * Useful for running readonly commands on a slot.
     */
    getSlotRandomNode(slot) {
        return this._slots.getSlotRandomNode(slot);
    }
    /**
     * @deprecated use `.masters` instead
     * TODO
     */
    getMasters() {
        return this.masters;
    }
    /**
     * @deprecated use `.slots[<SLOT>]` instead
     * TODO
     */
    getSlotMaster(slot) {
        return this.slots[slot].master;
    }
}
exports.default = RedisCluster;
