/// <reference types="node" />
import { RedisClusterOptions } from '.';
import { RedisClientType } from '../client';
import { EventEmitter } from 'node:stream';
import { ChannelListeners } from '../client/pub-sub';
import { RedisArgument, RedisFunctions, RedisModules, RedisScripts, RespVersions, TypeMapping } from '../RESP/types';
interface NodeAddress {
    host: string;
    port: number;
}
export type NodeAddressMap = {
    [address: string]: NodeAddress;
} | ((address: string) => NodeAddress | undefined);
export interface Node<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions, TYPE_MAPPING extends TypeMapping> {
    address: string;
    client?: RedisClientType<M, F, S, RESP, TYPE_MAPPING>;
    connectPromise?: Promise<RedisClientType<M, F, S, RESP, TYPE_MAPPING>>;
}
export interface ShardNode<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions, TYPE_MAPPING extends TypeMapping> extends Node<M, F, S, RESP, TYPE_MAPPING>, NodeAddress {
    id: string;
    readonly: boolean;
}
export interface MasterNode<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions, TYPE_MAPPING extends TypeMapping> extends ShardNode<M, F, S, RESP, TYPE_MAPPING> {
    pubSub?: {
        connectPromise?: Promise<RedisClientType<M, F, S, RESP, TYPE_MAPPING>>;
        client: RedisClientType<M, F, S, RESP, TYPE_MAPPING>;
    };
}
export interface Shard<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions, TYPE_MAPPING extends TypeMapping> {
    master: MasterNode<M, F, S, RESP, TYPE_MAPPING>;
    replicas?: Array<ShardNode<M, F, S, RESP, TYPE_MAPPING>>;
    nodesIterator?: IterableIterator<ShardNode<M, F, S, RESP, TYPE_MAPPING>>;
}
type PubSubNode<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions, TYPE_MAPPING extends TypeMapping> = (Omit<Node<M, F, S, RESP, TYPE_MAPPING>, 'client'> & Required<Pick<Node<M, F, S, RESP, TYPE_MAPPING>, 'client'>>);
export type OnShardedChannelMovedError = (err: unknown, channel: string, listeners?: ChannelListeners) => void;
export default class RedisClusterSlots<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions, TYPE_MAPPING extends TypeMapping> {
    private static _SLOTS;
    private readonly _options;
    private readonly _clientFactory;
    private readonly _emit;
    slots: Shard<M, F, S, RESP, TYPE_MAPPING>[];
    masters: MasterNode<M, F, S, RESP, TYPE_MAPPING>[];
    replicas: ShardNode<M, F, S, RESP, TYPE_MAPPING>[];
    readonly nodeByAddress: Map<string, MasterNode<M, F, S, RESP, TYPE_MAPPING> | ShardNode<M, F, S, RESP, TYPE_MAPPING>>;
    pubSubNode?: PubSubNode<M, F, S, RESP, TYPE_MAPPING>;
    private _isOpen;
    get isOpen(): boolean;
    constructor(options: RedisClusterOptions<M, F, S, RESP, TYPE_MAPPING>, emit: EventEmitter['emit']);
    connect(): Promise<void>;
    private _discoverWithRootNodes;
    private _resetSlots;
    private _discover;
    private _getShards;
    private _getNodeAddress;
    private _clientOptionsDefaults;
    private _initiateSlotNode;
    private _createClient;
    private _createNodeClient;
    nodeClient(node: ShardNode<M, F, S, RESP, TYPE_MAPPING>): RedisClientType<M, F, S, RESP, TYPE_MAPPING> | Promise<RedisClientType<M, F, S, RESP, TYPE_MAPPING>>;
    private _runningRediscoverPromise?;
    rediscover(startWith: RedisClientType<M, F, S, RESP>): Promise<void>;
    private _rediscover;
    /**
     * @deprecated Use `close` instead.
     */
    quit(): Promise<void>;
    /**
     * @deprecated Use `destroy` instead.
     */
    disconnect(): Promise<void>;
    close(): Promise<void>;
    destroy(): void;
    private _clients;
    private _destroy;
    getClient(firstKey: RedisArgument | undefined, isReadonly: boolean | undefined): RedisClientType<M, F, S, RESP, TYPE_MAPPING> | Promise<RedisClientType<M, F, S, RESP, TYPE_MAPPING>>;
    private _iterateAllNodes;
    _randomNodeIterator?: IterableIterator<ShardNode<M, F, S, RESP, TYPE_MAPPING>>;
    getRandomNode(): ShardNode<M, F, S, RESP, TYPE_MAPPING>;
    private _slotNodesIterator;
    getSlotRandomNode(slotNumber: number): ShardNode<M, F, S, RESP, TYPE_MAPPING>;
    getMasterByAddress(address: string): RedisClientType<M, F, S, RESP, TYPE_MAPPING> | Promise<RedisClientType<M, F, S, RESP, TYPE_MAPPING>> | undefined;
    getPubSubClient(): RedisClientType<M, F, S, RESP, TYPE_MAPPING> | Promise<RedisClientType<M, F, S, RESP, TYPE_MAPPING>>;
    private _initiatePubSubClient;
    executeUnsubscribeCommand(unsubscribe: (client: RedisClientType<M, F, S, RESP>) => Promise<void>): Promise<void>;
    getShardedPubSubClient(channel: string): RedisClientType<M, F, S, RESP, TYPE_MAPPING> | Promise<RedisClientType<M, F, S, RESP, TYPE_MAPPING>>;
    private _initiateShardedPubSubClient;
    executeShardedUnsubscribeCommand(channel: string, unsubscribe: (client: RedisClientType<M, F, S, RESP, TYPE_MAPPING>) => Promise<void>): Promise<void>;
}
export {};
