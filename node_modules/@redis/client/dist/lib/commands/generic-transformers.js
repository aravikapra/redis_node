"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pushZKeysArguments = exports.transformRangeReply = exports.pushSlotRangesArguments = exports.transformFunctionListItemReply = exports.RedisFunctionFlags = exports.transformCommandReply = exports.CommandCategories = exports.CommandFlags = exports.pushOptionalVariadicArgument = exports.pushVariadicArgument = exports.pushVariadicNumberArguments = exports.pushVariadicArguments = exports.pushEvalArguments = exports.evalFirstKeyIndex = exports.transformPXAT = exports.transformEXAT = exports.transformSortedSetReply = exports.transformStreamMessageNullReply = exports.transformStreamMessageReply = exports.transformTuplesReply = exports.transformNullableDoubleReply = exports.transformDoubleArrayReply = exports.transformDoubleReply = exports.transformStringDoubleArgument = exports.transformDoubleArgument = exports.transformBooleanArrayReply = exports.transformBooleanReply = exports.isArrayReply = exports.isNullReply = void 0;
function isNullReply(reply) {
    return reply === null;
}
exports.isNullReply = isNullReply;
function isArrayReply(reply) {
    return Array.isArray(reply);
}
exports.isArrayReply = isArrayReply;
exports.transformBooleanReply = {
    2: (reply) => reply === 1,
    3: undefined
};
exports.transformBooleanArrayReply = {
    2: (reply) => {
        return reply.map(exports.transformBooleanReply[2]);
    },
    3: undefined
};
function transformDoubleArgument(num) {
    switch (num) {
        case Infinity:
            return '+inf';
        case -Infinity:
            return '-inf';
        default:
            return num.toString();
    }
}
exports.transformDoubleArgument = transformDoubleArgument;
function transformStringDoubleArgument(num) {
    if (typeof num !== 'number')
        return num;
    return transformDoubleArgument(num);
}
exports.transformStringDoubleArgument = transformStringDoubleArgument;
exports.transformDoubleReply = {
    2: (reply) => {
        switch (reply.toString()) {
            case 'inf':
            case '+inf':
                return Infinity;
            case '-inf':
                return -Infinity;
            case 'nan':
                return NaN;
            default:
                return Number(reply);
        }
    },
    3: undefined
};
exports.transformDoubleArrayReply = {
    2: (reply) => reply.map(exports.transformDoubleReply[2]),
    3: undefined
};
exports.transformNullableDoubleReply = {
    2: (reply) => {
        if (reply === null)
            return null;
        return exports.transformDoubleReply[2](reply);
    },
    3: undefined
};
function transformTuplesReply(reply) {
    const inferred = reply, message = Object.create(null);
    for (let i = 0; i < inferred.length; i += 2) {
        message[inferred[i].toString()] = inferred[i + 1];
    }
    return message;
}
exports.transformTuplesReply = transformTuplesReply;
function transformStreamMessageReply(reply) {
    const [id, message] = reply;
    return {
        id,
        message: transformTuplesReply(message)
    };
}
exports.transformStreamMessageReply = transformStreamMessageReply;
function transformStreamMessageNullReply(reply) {
    return isNullReply(reply) ? reply : transformStreamMessageReply(reply);
}
exports.transformStreamMessageNullReply = transformStreamMessageNullReply;
exports.transformSortedSetReply = {
    2: (reply) => {
        const inferred = reply, members = [];
        for (let i = 0; i < inferred.length; i += 2) {
            members.push({
                value: inferred[i],
                score: exports.transformDoubleReply[2](inferred[i + 1])
            });
        }
        return members;
    },
    3: (reply) => {
        return reply.map(member => {
            const [value, score] = member;
            return {
                value,
                score
            };
        });
    }
};
function transformEXAT(EXAT) {
    return (typeof EXAT === 'number' ? EXAT : Math.floor(EXAT.getTime() / 1000)).toString();
}
exports.transformEXAT = transformEXAT;
function transformPXAT(PXAT) {
    return (typeof PXAT === 'number' ? PXAT : PXAT.getTime()).toString();
}
exports.transformPXAT = transformPXAT;
function evalFirstKeyIndex(options) {
    return options?.keys?.[0];
}
exports.evalFirstKeyIndex = evalFirstKeyIndex;
function pushEvalArguments(args, options) {
    if (options?.keys) {
        args.push(options.keys.length.toString(), ...options.keys);
    }
    else {
        args.push('0');
    }
    if (options?.arguments) {
        args.push(...options.arguments);
    }
    return args;
}
exports.pushEvalArguments = pushEvalArguments;
function pushVariadicArguments(args, value) {
    if (Array.isArray(value)) {
        // https://github.com/redis/node-redis/pull/2160
        args = args.concat(value);
    }
    else {
        args.push(value);
    }
    return args;
}
exports.pushVariadicArguments = pushVariadicArguments;
function pushVariadicNumberArguments(args, value) {
    if (Array.isArray(value)) {
        for (const item of value) {
            args.push(item.toString());
        }
    }
    else {
        args.push(value.toString());
    }
    return args;
}
exports.pushVariadicNumberArguments = pushVariadicNumberArguments;
function pushVariadicArgument(args, value) {
    if (Array.isArray(value)) {
        args.push(value.length.toString(), ...value);
    }
    else {
        args.push('1', value);
    }
    return args;
}
exports.pushVariadicArgument = pushVariadicArgument;
function pushOptionalVariadicArgument(args, name, value) {
    if (value === undefined)
        return args;
    args.push(name);
    return pushVariadicArgument(args, value);
}
exports.pushOptionalVariadicArgument = pushOptionalVariadicArgument;
var CommandFlags;
(function (CommandFlags) {
    CommandFlags["WRITE"] = "write";
    CommandFlags["READONLY"] = "readonly";
    CommandFlags["DENYOOM"] = "denyoom";
    CommandFlags["ADMIN"] = "admin";
    CommandFlags["PUBSUB"] = "pubsub";
    CommandFlags["NOSCRIPT"] = "noscript";
    CommandFlags["RANDOM"] = "random";
    CommandFlags["SORT_FOR_SCRIPT"] = "sort_for_script";
    CommandFlags["LOADING"] = "loading";
    CommandFlags["STALE"] = "stale";
    CommandFlags["SKIP_MONITOR"] = "skip_monitor";
    CommandFlags["ASKING"] = "asking";
    CommandFlags["FAST"] = "fast";
    CommandFlags["MOVABLEKEYS"] = "movablekeys"; // keys have no pre-determined position. You must discover keys yourself.
})(CommandFlags || (exports.CommandFlags = CommandFlags = {}));
var CommandCategories;
(function (CommandCategories) {
    CommandCategories["KEYSPACE"] = "@keyspace";
    CommandCategories["READ"] = "@read";
    CommandCategories["WRITE"] = "@write";
    CommandCategories["SET"] = "@set";
    CommandCategories["SORTEDSET"] = "@sortedset";
    CommandCategories["LIST"] = "@list";
    CommandCategories["HASH"] = "@hash";
    CommandCategories["STRING"] = "@string";
    CommandCategories["BITMAP"] = "@bitmap";
    CommandCategories["HYPERLOGLOG"] = "@hyperloglog";
    CommandCategories["GEO"] = "@geo";
    CommandCategories["STREAM"] = "@stream";
    CommandCategories["PUBSUB"] = "@pubsub";
    CommandCategories["ADMIN"] = "@admin";
    CommandCategories["FAST"] = "@fast";
    CommandCategories["SLOW"] = "@slow";
    CommandCategories["BLOCKING"] = "@blocking";
    CommandCategories["DANGEROUS"] = "@dangerous";
    CommandCategories["CONNECTION"] = "@connection";
    CommandCategories["TRANSACTION"] = "@transaction";
    CommandCategories["SCRIPTING"] = "@scripting";
})(CommandCategories || (exports.CommandCategories = CommandCategories = {}));
function transformCommandReply([name, arity, flags, firstKeyIndex, lastKeyIndex, step, categories]) {
    return {
        name,
        arity,
        flags: new Set(flags),
        firstKeyIndex,
        lastKeyIndex,
        step,
        categories: new Set(categories)
    };
}
exports.transformCommandReply = transformCommandReply;
var RedisFunctionFlags;
(function (RedisFunctionFlags) {
    RedisFunctionFlags["NO_WRITES"] = "no-writes";
    RedisFunctionFlags["ALLOW_OOM"] = "allow-oom";
    RedisFunctionFlags["ALLOW_STALE"] = "allow-stale";
    RedisFunctionFlags["NO_CLUSTER"] = "no-cluster";
})(RedisFunctionFlags || (exports.RedisFunctionFlags = RedisFunctionFlags = {}));
function transformFunctionListItemReply(reply) {
    return {
        libraryName: reply[1],
        engine: reply[3],
        functions: reply[5].map(fn => ({
            name: fn[1],
            description: fn[3],
            flags: fn[5]
        }))
    };
}
exports.transformFunctionListItemReply = transformFunctionListItemReply;
function pushSlotRangeArguments(args, range) {
    args.push(range.start.toString(), range.end.toString());
}
function pushSlotRangesArguments(args, ranges) {
    if (Array.isArray(ranges)) {
        for (const range of ranges) {
            pushSlotRangeArguments(args, range);
        }
    }
    else {
        pushSlotRangeArguments(args, ranges);
    }
    return args;
}
exports.pushSlotRangesArguments = pushSlotRangesArguments;
function transformRangeReply([start, end]) {
    return {
        start,
        end
    };
}
exports.transformRangeReply = transformRangeReply;
function pushZKeysArguments(args, keys) {
    if (Array.isArray(keys)) {
        args.push(keys.length.toString());
        if (keys.length) {
            if (isPlainKeys(keys)) {
                args = args.concat(keys);
            }
            else {
                const start = args.length;
                args[start + keys.length] = 'WEIGHTS';
                for (let i = 0; i < keys.length; i++) {
                    const index = start + i;
                    args[index] = keys[i].key;
                    args[index + 1 + keys.length] = transformDoubleArgument(keys[i].weight);
                }
            }
        }
    }
    else {
        args.push('1');
        if (isPlainKey(keys)) {
            args.push(keys);
        }
        else {
            args.push(keys.key, 'WEIGHTS', transformDoubleArgument(keys.weight));
        }
    }
    return args;
}
exports.pushZKeysArguments = pushZKeysArguments;
function isPlainKey(key) {
    return typeof key === 'string' || key instanceof Buffer;
}
function isPlainKeys(keys) {
    return isPlainKey(keys[0]);
}
