/// <reference types="node" />
import type { BlobStringReply, CommandArguments, DoubleReply, NumberReply, RedisArgument, TuplesReply, UnwrapReply } from '@redis/client/dist/lib/RESP/types';
import { RedisVariadicArgument } from '@redis/client/dist/lib/commands/generic-transformers';
declare const _default: {
    readonly ADD: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, key: RedisArgument, timestamp: Timestamp, value: number, options?: import("./ADD").TsAddOptions | undefined) => RedisArgument[];
        readonly transformReply: () => NumberReply<number>;
    };
    readonly add: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, key: RedisArgument, timestamp: Timestamp, value: number, options?: import("./ADD").TsAddOptions | undefined) => RedisArgument[];
        readonly transformReply: () => NumberReply<number>;
    };
    readonly ALTER: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, key: RedisArgument, options?: import("./ALTER").TsAlterOptions | undefined) => RedisArgument[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").SimpleStringReply<"OK">;
    };
    readonly alter: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, key: RedisArgument, options?: import("./ALTER").TsAlterOptions | undefined) => RedisArgument[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").SimpleStringReply<"OK">;
    };
    readonly CREATE: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, key: RedisArgument, options?: import("./CREATE").TsCreateOptions | undefined) => RedisArgument[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").SimpleStringReply<"OK">;
    };
    readonly create: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, key: RedisArgument, options?: import("./CREATE").TsCreateOptions | undefined) => RedisArgument[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").SimpleStringReply<"OK">;
    };
    readonly CREATERULE: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, sourceKey: RedisArgument, destinationKey: RedisArgument, aggregationType: import("./CREATERULE").TimeSeriesAggregationType, bucketDuration: number, alignTimestamp?: number | undefined) => (string | Buffer)[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").SimpleStringReply<"OK">;
    };
    readonly createRule: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, sourceKey: RedisArgument, destinationKey: RedisArgument, aggregationType: import("./CREATERULE").TimeSeriesAggregationType, bucketDuration: number, alignTimestamp?: number | undefined) => (string | Buffer)[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").SimpleStringReply<"OK">;
    };
    readonly DECRBY: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (key: RedisArgument, value: number, options?: import("./INCRBY").TsIncrByOptions | undefined) => RedisArgument[];
        readonly transformReply: () => NumberReply<number>;
    };
    readonly decrBy: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (key: RedisArgument, value: number, options?: import("./INCRBY").TsIncrByOptions | undefined) => RedisArgument[];
        readonly transformReply: () => NumberReply<number>;
    };
    readonly DEL: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, key: RedisArgument, fromTimestamp: Timestamp, toTimestamp: Timestamp) => RedisArgument[];
        readonly transformReply: () => NumberReply<number>;
    };
    readonly del: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, key: RedisArgument, fromTimestamp: Timestamp, toTimestamp: Timestamp) => RedisArgument[];
        readonly transformReply: () => NumberReply<number>;
    };
    readonly DELETERULE: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, sourceKey: RedisArgument, destinationKey: RedisArgument) => RedisArgument[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").SimpleStringReply<"OK">;
    };
    readonly deleteRule: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, sourceKey: RedisArgument, destinationKey: RedisArgument) => RedisArgument[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").SimpleStringReply<"OK">;
    };
    readonly GET: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (this: void, key: RedisArgument, options?: import("./GET").TsGetOptions | undefined) => RedisArgument[];
        readonly transformReply: {
            readonly 2: (this: void, reply: UnwrapReply<import("@redis/client/dist/lib/RESP/types").Resp2Reply<import("./GET").TsGetReply>>) => {
                timestamp: NumberReply<number>;
                value: number;
            } | null;
            readonly 3: (this: void, reply: UnwrapReply<import("./GET").TsGetReply>) => {
                timestamp: NumberReply<number>;
                value: DoubleReply<number>;
            } | null;
        };
    };
    readonly get: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (this: void, key: RedisArgument, options?: import("./GET").TsGetOptions | undefined) => RedisArgument[];
        readonly transformReply: {
            readonly 2: (this: void, reply: UnwrapReply<import("@redis/client/dist/lib/RESP/types").Resp2Reply<import("./GET").TsGetReply>>) => {
                timestamp: NumberReply<number>;
                value: number;
            } | null;
            readonly 3: (this: void, reply: UnwrapReply<import("./GET").TsGetReply>) => {
                timestamp: NumberReply<number>;
                value: DoubleReply<number>;
            } | null;
        };
    };
    readonly INCRBY: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (key: RedisArgument, value: number, options?: import("./INCRBY").TsIncrByOptions | undefined) => RedisArgument[];
        readonly transformReply: () => NumberReply<number>;
    };
    readonly incrBy: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (key: RedisArgument, value: number, options?: import("./INCRBY").TsIncrByOptions | undefined) => RedisArgument[];
        readonly transformReply: () => NumberReply<number>;
    };
    readonly MADD: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, toAdd: import("./MADD").TsMAddSample[]) => string[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").ArrayReply<NumberReply<number> | import("@redis/client/dist/lib/RESP/types").SimpleErrorReply>;
    };
    readonly mAdd: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: false;
        readonly transformArguments: (this: void, toAdd: import("./MADD").TsMAddSample[]) => string[];
        readonly transformReply: () => import("@redis/client/dist/lib/RESP/types").ArrayReply<NumberReply<number> | import("@redis/client/dist/lib/RESP/types").SimpleErrorReply>;
    };
    readonly MGET_WITHLABELS: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (this: void, filter: RedisVariadicArgument, options?: import("./MGET_WITHLABELS").TsMGetWithLabelsOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly mGetWithLabels: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (this: void, filter: RedisVariadicArgument, options?: import("./MGET_WITHLABELS").TsMGetWithLabelsOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly MGET: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (this: void, filter: RedisVariadicArgument, options?: import("./MGET").TsMGetOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly mGet: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (this: void, filter: RedisVariadicArgument, options?: import("./MGET").TsMGetOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly MRANGE_WITHLABELS: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (fromTimestamp: Timestamp, toTimestamp: Timestamp, filter: RedisVariadicArgument, options?: import("./MRANGE_WITHLABELS").TsMRangeWithLabelsOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly mRangeWithLabels: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (fromTimestamp: Timestamp, toTimestamp: Timestamp, filter: RedisVariadicArgument, options?: import("./MRANGE_WITHLABELS").TsMRangeWithLabelsOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly MRANGE: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (fromTimestamp: Timestamp, toTimestamp: Timestamp, filter: RedisVariadicArgument, options?: import("./MRANGE").TsMRangeOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly mRange: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (fromTimestamp: Timestamp, toTimestamp: Timestamp, filter: RedisVariadicArgument, options?: import("./MRANGE").TsMRangeOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly MREVRANGE_WITHLABELS: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (fromTimestamp: Timestamp, toTimestamp: Timestamp, filter: RedisVariadicArgument, options?: import("./MRANGE_WITHLABELS").TsMRangeWithLabelsOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly mRevRangeWithLabels: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (fromTimestamp: Timestamp, toTimestamp: Timestamp, filter: RedisVariadicArgument, options?: import("./MRANGE_WITHLABELS").TsMRangeWithLabelsOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly MREVRANGE: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (fromTimestamp: Timestamp, toTimestamp: Timestamp, filter: RedisVariadicArgument, options?: import("./MRANGE").TsMRangeOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly mRevRange: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (fromTimestamp: Timestamp, toTimestamp: Timestamp, filter: RedisVariadicArgument, options?: import("./MRANGE").TsMRangeOptions | undefined) => CommandArguments;
        readonly transformReply: () => any;
    };
    readonly QUERYINDEX: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (this: void, filter: RedisVariadicArgument) => CommandArguments;
        readonly transformReply: {
            readonly 2: () => import("@redis/client/dist/lib/RESP/types").ArrayReply<BlobStringReply<string>>;
            readonly 3: () => import("@redis/client/dist/lib/RESP/types").SetReply<BlobStringReply<string>>;
        };
    };
    readonly queryIndex: {
        readonly FIRST_KEY_INDEX: undefined;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (this: void, filter: RedisVariadicArgument) => CommandArguments;
        readonly transformReply: {
            readonly 2: () => import("@redis/client/dist/lib/RESP/types").ArrayReply<BlobStringReply<string>>;
            readonly 3: () => import("@redis/client/dist/lib/RESP/types").SetReply<BlobStringReply<string>>;
        };
    };
    readonly RANGE: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (key: RedisArgument, fromTimestamp: Timestamp, toTimestamp: Timestamp, options?: import("./RANGE").TsRangeOptions | undefined) => CommandArguments;
        readonly transformReply: {
            readonly 2: (this: void, reply: TuplesReply<[timestamp: NumberReply<number>, value: BlobStringReply<string>]>[]) => {
                timestamp: NumberReply<number>;
                value: number;
            }[];
            readonly 3: (this: void, reply: TuplesReply<[timestamp: NumberReply<number>, value: DoubleReply<number>]>[]) => {
                timestamp: NumberReply<number>;
                value: DoubleReply<number>;
            }[];
        };
    };
    readonly range: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (key: RedisArgument, fromTimestamp: Timestamp, toTimestamp: Timestamp, options?: import("./RANGE").TsRangeOptions | undefined) => CommandArguments;
        readonly transformReply: {
            readonly 2: (this: void, reply: TuplesReply<[timestamp: NumberReply<number>, value: BlobStringReply<string>]>[]) => {
                timestamp: NumberReply<number>;
                value: number;
            }[];
            readonly 3: (this: void, reply: TuplesReply<[timestamp: NumberReply<number>, value: DoubleReply<number>]>[]) => {
                timestamp: NumberReply<number>;
                value: DoubleReply<number>;
            }[];
        };
    };
    readonly REVRANGE: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (key: RedisArgument, fromTimestamp: Timestamp, toTimestamp: Timestamp, options?: import("./RANGE").TsRangeOptions | undefined) => CommandArguments;
        readonly transformReply: {
            readonly 2: (this: void, reply: TuplesReply<[timestamp: NumberReply<number>, value: BlobStringReply<string>]>[]) => {
                timestamp: NumberReply<number>;
                value: number;
            }[];
            readonly 3: (this: void, reply: TuplesReply<[timestamp: NumberReply<number>, value: DoubleReply<number>]>[]) => {
                timestamp: NumberReply<number>;
                value: DoubleReply<number>;
            }[];
        };
    };
    readonly revRange: {
        readonly FIRST_KEY_INDEX: 1;
        readonly IS_READ_ONLY: true;
        readonly transformArguments: (key: RedisArgument, fromTimestamp: Timestamp, toTimestamp: Timestamp, options?: import("./RANGE").TsRangeOptions | undefined) => CommandArguments;
        readonly transformReply: {
            readonly 2: (this: void, reply: TuplesReply<[timestamp: NumberReply<number>, value: BlobStringReply<string>]>[]) => {
                timestamp: NumberReply<number>;
                value: number;
            }[];
            readonly 3: (this: void, reply: TuplesReply<[timestamp: NumberReply<number>, value: DoubleReply<number>]>[]) => {
                timestamp: NumberReply<number>;
                value: DoubleReply<number>;
            }[];
        };
    };
};
export default _default;
export declare function pushRetentionArgument(args: Array<RedisArgument>, retention?: number): void;
export declare const TIME_SERIES_ENCODING: {
    readonly COMPRESSED: "COMPRESSED";
    readonly UNCOMPRESSED: "UNCOMPRESSED";
};
export type TimeSeriesEncoding = typeof TIME_SERIES_ENCODING[keyof typeof TIME_SERIES_ENCODING];
export declare function pushEncodingArgument(args: Array<RedisArgument>, encoding?: TimeSeriesEncoding): void;
export declare function pushChunkSizeArgument(args: Array<RedisArgument>, chunkSize?: number): void;
export declare const TIME_SERIES_DUPLICATE_POLICIES: {
    readonly BLOCK: "BLOCK";
    readonly FIRST: "FIRST";
    readonly LAST: "LAST";
    readonly MIN: "MIN";
    readonly MAX: "MAX";
    readonly SUM: "SUM";
};
export type TimeSeriesDuplicatePolicies = typeof TIME_SERIES_DUPLICATE_POLICIES[keyof typeof TIME_SERIES_DUPLICATE_POLICIES];
export declare function pushDuplicatePolicy(args: Array<RedisArgument>, duplicatePolicy?: TimeSeriesDuplicatePolicies): void;
export type Timestamp = number | Date | string;
export declare function transformTimestampArgument(timestamp: Timestamp): string;
export type Labels = {
    [label: string]: string;
};
export declare function pushLabelsArgument(args: Array<RedisArgument>, labels?: Labels): RedisArgument[];
export type SampleRawReply = {
    2: TuplesReply<[timestamp: NumberReply, value: BlobStringReply]>;
    3: TuplesReply<[timestamp: NumberReply, value: DoubleReply]>;
};
export declare const transformSampleReply: {
    2(reply: SampleRawReply[2]): {
        timestamp: NumberReply<number>;
        value: number;
    };
    3(reply: SampleRawReply[3]): {
        timestamp: NumberReply<number>;
        value: DoubleReply<number>;
    };
};
export declare function pushWithLabelsArgument(args: CommandArguments, selectedLabels?: RedisVariadicArgument): CommandArguments;
